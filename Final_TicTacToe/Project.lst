Microsoft (R) Macro Assembler Version 14.16.27026.1	    03/17/19 00:03:15
Tic Tac Toe     (TicTacToe.asm				     Page 1 - 1


				TITLE Tic Tac Toe     (TicTacToe.asm)

				; Author: Ethan Duong
				; Course / Project ID: CS 271 EC Program           Date: 1/26/19
				; Description: This program simulates the game, Tic Tac Toe.

				INCLUDE Irvine32.inc
			      C ; Include file for Irvine32.lib             (Irvine32.inc)
			      C 
			      C ;OPTION CASEMAP:NONE		; optional: make identifiers case-sensitive
			      C 
			      C INCLUDE SmallWin.inc		; MS-Windows prototypes, structures, and constants
			      C .NOLIST
			      C .LIST
			      C 
			      C INCLUDE VirtualKeys.inc
			      C ; VirtualKeys.inc
			      C .NOLIST
			      C .LIST
			      C 
			      C 
			      C .NOLIST
			      C .LIST
			      C 

				; (insert constant definitions here)
 = 00000065			MAX_LENGTH_NAME = 101	; max length of user's name

				;---------------------------------------------------
				; display the received string
				;
				; registers used: edx
				; Receives: a string
				; Returns: nothing
				;---------------------------------------------------
				displayString MACRO msg1
					push	edx
					mov		edx, OFFSET msg1
					call	WriteString
					pop		edx
				ENDM

 00000000			.data
				; Messages
 00000000 4D 79 20 6E 61	welcomeMsg		BYTE	"My name is Ethan Duong and welcome to tic-tac-toe.", 0dh, 0ah, 0
	   6D 65 20 69 73
	   20 45 74 68 61
	   6E 20 44 75 6F
	   6E 67 20 61 6E
	   64 20 77 65 6C
	   63 6F 6D 65 20
	   74 6F 20 74 69
	   63 2D 74 61 63
	   2D 74 6F 65 2E
	   0D 0A 00
 00000035 50 6C 65 61 73	getName			BYTE	"Please enter your name: ", 0
	   65 20 65 6E 74
	   65 72 20 79 6F
	   75 72 20 6E 61
	   6D 65 3A 20 00
 0000004E 48 65 6C 6C 6F	greetMsg1		BYTE	"Hello, ", 0
	   2C 20 00
 00000056 2C 20 6C 65 74	greetMsg2		BYTE	", let's play tic-tac-toe. Games are played best two out of three.", 0dh, 0ah, 0
	   27 73 20 70 6C
	   61 79 20 74 69
	   63 2D 74 61 63
	   2D 74 6F 65 2E
	   20 47 61 6D 65
	   73 20 61 72 65
	   20 70 6C 61 79
	   65 64 20 62 65
	   73 74 20 74 77
	   6F 20 6F 75 74
	   20 6F 66 20 74
	   68 72 65 65 2E
	   0D 0A 00
 0000009A 50 6C 65 61 73	instrcMsg		BYTE	"Please enter an integer from 1 to 9 to make a move. (Think of a numpad)", 0dh, 0ah, 0
	   65 20 65 6E 74
	   65 72 20 61 6E
	   20 69 6E 74 65
	   67 65 72 20 66
	   72 6F 6D 20 31
	   20 74 6F 20 39
	   20 74 6F 20 6D
	   61 6B 65 20 61
	   20 6D 6F 76 65
	   2E 20 28 54 68
	   69 6E 6B 20 6F
	   66 20 61 20 6E
	   75 6D 70 61 64
	   29 0D 0A 00
 000000E4 59 6F 75 20 65	checkMsg		BYTE	"You entered: ", 0
	   6E 74 65 72 65
	   64 3A 20 00
 000000F2 54 68 61 74 20	invalidMsg		BYTE	"That is not a valid move.", 0dh, 0ah, 0
	   69 73 20 6E 6F
	   74 20 61 20 76
	   61 6C 69 64 20
	   6D 6F 76 65 2E
	   0D 0A 00
 0000010E 44 6F 20 79 6F	againMsg		BYTE	"Do you want to play again? (Enter 1 for yes, anything else for no)", 0dh, 0ah, 0
	   75 20 77 61 6E
	   74 20 74 6F 20
	   70 6C 61 79 20
	   61 67 61 69 6E
	   3F 20 28 45 6E
	   74 65 72 20 31
	   20 66 6F 72 20
	   79 65 73 2C 20
	   61 6E 79 74 68
	   69 6E 67 20 65
	   6C 73 65 20 66
	   6F 72 20 6E 6F
	   29 0D 0A 00
 00000153 49 20 68 6F 70	byeMsg			BYTE	"I hope you liked playing tic-tac-toe, ", 0
	   65 20 79 6F 75
	   20 6C 69 6B 65
	   64 20 70 6C 61
	   79 69 6E 67 20
	   74 69 63 2D 74
	   61 63 2D 74 6F
	   65 2C 20 00
 0000017A 57 6F 75 6C 64	gameModeMsg		BYTE	"Would you like to play with a friend or against a computer? (1 for computer, anything else for human)", 0dh, 0ah, 0
	   20 79 6F 75 20
	   6C 69 6B 65 20
	   74 6F 20 70 6C
	   61 79 20 77 69
	   74 68 20 61 20
	   66 72 69 65 6E
	   64 20 6F 72 20
	   61 67 61 69 6E
	   73 74 20 61 20
	   63 6F 6D 70 75
	   74 65 72 3F 20
	   28 31 20 66 6F
	   72 20 63 6F 6D
	   70 75 74 65 72
	   2C 20 61 6E 79
	   74 68 69 6E 67
	   20 65 6C 73 65
	   20 66 6F 72 20
	   68 75 6D 61 6E
	   29 0D 0A 00
 000001E2 50 6C 61 79 65	player1Msg		BYTE	"Player 1, make a move.", 0dh, 0ah, 0
	   72 20 31 2C 20
	   6D 61 6B 65 20
	   61 20 6D 6F 76
	   65 2E 0D 0A 00
 000001FB 50 6C 61 79 65	player2Msg		BYTE	"Player 2, make a move.", 0dh, 0ah, 0
	   72 20 32 2C 20
	   6D 61 6B 65 20
	   61 20 6D 6F 76
	   65 2E 0D 0A 00
 00000214 54 68 61 74 20	filledMsg		BYTE	"That space is already taken!", 0dh, 0ah, 0
	   73 70 61 63 65
	   20 69 73 20 61
	   6C 72 65 61 64
	   79 20 74 61 6B
	   65 6E 21 0D 0A
	   00
 00000233 50 6C 61 79 65	xWinMsg			BYTE	"Player 1 has won!", 0dh, 0ah, 0
	   72 20 31 20 68
	   61 73 20 77 6F
	   6E 21 0D 0A 00
 00000247 50 6C 61 79 65	oWinMsg			BYTE	"Player 2 has won!", 0dh, 0ah, 0
	   72 20 32 20 68
	   61 73 20 77 6F
	   6E 21 0D 0A 00
 0000025B 53 74 61 6C 65	tieMsg			BYTE	"Stalemate!", 0dh, 0ah, 0
	   6D 61 74 65 21
	   0D 0A 00
 00000268 54 68 65 20 63	cpuMsg			BYTE	"The computer has made its move.", 0dh, 0ah, 0
	   6F 6D 70 75 74
	   65 72 20 68 61
	   73 20 6D 61 64
	   65 20 69 74 73
	   20 6D 6F 76 65
	   2E 0D 0A 00
 0000028A 57 68 6F 20 73	orderMsg		BYTE	"Who should go first? (1 for player1, anything else for player 2)", 0dh, 0ah, 0
	   68 6F 75 6C 64
	   20 67 6F 20 66
	   69 72 73 74 3F
	   20 28 31 20 66
	   6F 72 20 70 6C
	   61 79 65 72 31
	   2C 20 61 6E 79
	   74 68 69 6E 67
	   20 65 6C 73 65
	   20 66 6F 72 20
	   70 6C 61 79 65
	   72 20 32 29 0D
	   0A 00
 000002CD 41 6E 6F 74 68	rematchMsg		BYTE	"Another game is beginning!", 0dh, 0ah, 0
	   65 72 20 67 61
	   6D 65 20 69 73
	   20 62 65 67 69
	   6E 6E 69 6E 67
	   21 0D 0A 00
 000002EA 50 6C 61 79 65	player1Won		BYTE	"Player 1 has won the best two out of three!", 0dh, 0ah, 0
	   72 20 31 20 68
	   61 73 20 77 6F
	   6E 20 74 68 65
	   20 62 65 73 74
	   20 74 77 6F 20
	   6F 75 74 20 6F
	   66 20 74 68 72
	   65 65 21 0D 0A
	   00
 00000318 50 6C 61 79 65	player2Won		BYTE	"Player 2 has won the best two out of three!", 0dh, 0ah, 0
	   72 20 32 20 68
	   61 73 20 77 6F
	   6E 20 74 68 65
	   20 62 65 73 74
	   20 74 77 6F 20
	   6F 75 74 20 6F
	   66 20 74 68 72
	   65 65 21 0D 0A
	   00
 00000346 45 6E 74 65 72	instrcMsg2		BYTE	"Enter the respective number to make that move (Think of a numpad).", 0dh, 0ah, 0
	   20 74 68 65 20
	   72 65 73 70 65
	   63 74 69 76 65
	   20 6E 75 6D 62
	   65 72 20 74 6F
	   20 6D 61 6B 65
	   20 74 68 61 74
	   20 6D 6F 76 65
	   20 28 54 68 69
	   6E 6B 20 6F 66
	   20 61 20 6E 75
	   6D 70 61 64 29
	   2E 0D 0A 00
				; board states
 0000038B 20 20 20 7C 20	boardLine1		BYTE	"   |   |   ", 0dh, 0ah, 0	; line 1, 3, 5, 7, 9
	   20 20 7C 20 20
	   20 0D 0A 00
 00000399 20 00			boardLine214	BYTE	" ", 0						; line (2, 6, 10) spaces 1, 4
 0000039B 20 7C 20 00		boardLine223	BYTE	" | ", 0					; line (2, 6, 10) spaces 2, 3
 0000039F 2D 2D 2D 2D 2D	boardLine4		BYTE	"-----------", 0dh, 0ah, 0	; line 4, 8
	   2D 2D 2D 2D 2D
	   2D 0D 0A 00
				; variables
 000003AD  00000065 [		userName		BYTE	MAX_LENGTH_NAME		DUP (0)	; user's name
	    00
	   ]
 00000412  00000001 [		currentChar		BYTE	1					DUP	(0)	; current player X or O
	    00
	   ]
 00000413 00000000		player1Wins		DWORD	0							; player 1's number of wins
 00000417 00000000		player2Wins		DWORD	0							; player 2's number of wins
				; bools
 0000041B 00000000		gameIsOver		DWORD	0	; if board is full or someone has won
 0000041F 00000000		againBool		DWORD	0	; if user wants to play again
 00000423 00000000		gameModeType	DWORD	0	; 0 for human v human, 1 for human v cpu
 00000427 00000000		orderBool		DWORD	0	; 1 for human first, other for cpu
				; variables for board positions
 0000042B 31 00			space1			BYTE	"1", 0
 0000042D 32 00			space2			BYTE	"2", 0
 0000042F 33 00			space3			BYTE	"3", 0
 00000431 34 00			space4			BYTE	"4", 0
 00000433 35 00			space5			BYTE	"5", 0
 00000435 36 00			space6			BYTE	"6", 0
 00000437 37 00			space7			BYTE	"7", 0
 00000439 38 00			space8			BYTE	"8", 0
 0000043B 39 00			space9			BYTE	"9", 0
				; bools for if space is occupied
 0000043D 00000000		space1Bool		DWORD	0
 00000441 00000000		space2Bool		DWORD	0
 00000445 00000000		space3Bool		DWORD	0
 00000449 00000000		space4Bool		DWORD	0
 0000044D 00000000		space5Bool		DWORD	0
 00000451 00000000		space6Bool		DWORD	0
 00000455 00000000		space7Bool		DWORD	0
 00000459 00000000		space8Bool		DWORD	0
 0000045D 00000000		space9Bool		DWORD	0

 00000000			.code
 00000000			main PROC
 00000000  68 000003AD R		push	OFFSET username		; user's name
 00000005  E8 00000201			call	introduction		; greet user and display instructions

 0000000A				startAgain:					; label for if user wants to play again
 0000000A  E8 00000000 E		call	randomize			; randomize the numbers
 0000000F  E8 00000251			call	displayBoard		; display tic tac toe board with numbers
					displayString instrcMsg2    ; tell user how to make moves
 00000014  52		     1		push	edx
 00000015  BA 00000346 R     1		mov		edx, OFFSET instrcMsg2
 0000001A  E8 00000000 E     1		call	WriteString
 0000001F  5A		     1		pop		edx
 00000020  68 0000041B R		push	OFFSET gameIsOver	; if the game needs to be reset
 00000025  E8 00000F43			call	resetGame			; reset board values
 0000002A  68 00000423 R		push	OFFSET gameModeType ; bool of game type
 0000002F  E8 00001001			call	getGameMode			; if user wants to play with human or cpu
 00000034				rematch:					; label for playing same mode again
 00000034  83 3D 00000423 R		cmp		gameModeType, 1		; if human v cpu
	   01
 0000003B  0F 84 000000B7		je		cpuStart			; play against cpu

 00000041				humanLoop: ; human vs human
						; get player order
						displayString orderMsg
 00000041  52		     1		push	edx
 00000042  BA 0000028A R     1		mov		edx, OFFSET orderMsg
 00000047  E8 00000000 E     1		call	WriteString
 0000004C  5A		     1		pop		edx
 0000004D  E8 00000000 E			call	ReadDec
						;call	displayBoard		; show tic tac toe board
 00000052  83 F8 01				cmp		eax, 1				; if input is 1 then player1 goes first
 00000055  75 4E				jne		player2Start		; skip player1's turn
 00000057				player1Start: ; get move for player 1
 00000057  E8 00000209				call	displayBoard		; update board
						displayString player1Msg	; prompt player 1
 0000005C  52		     1		push	edx
 0000005D  BA 000001E2 R     1		mov		edx, OFFSET player1Msg
 00000062  E8 00000000 E     1		call	WriteString
 00000067  5A		     1		pop		edx
 00000068  E8 00000373				call	getMoveX			; player 1 makes a move
						; check if board is full or someone won
 0000006D  68 00000413 R			push	OFFSET player1Wins  ; number of times player 1 has won
 00000072  68 00000417 R			push	OFFSET player2Wins	; number of times player 2 has won
 00000077  68 0000041B R			push	OFFSET gameIsOver	; bool if game is over
 0000007C  E8 00000A5B				call	checkGameWin		; check if someone won
 00000081  83 3D 0000041B R			cmp		gameIsOver, 1		; check if player 1 has won
	   01
 00000088  0F 84 000000F9			je		endLoop				; then exit game
 0000008E  68 0000041B R			push	OFFSET gameIsOver	; bool if game is over
 00000093  E8 00000837				call	checkBoardFull		; check if there are no possible moves left
 00000098  83 3D 0000041B R			cmp		gameIsOver, 1		; check if board full
	   01
 0000009F  0F 84 000000E2			je		endLoop				; then exit game
 000000A5				player2Start: ; get move for player 2
 000000A5  E8 000001BB				call	displayBoard		; update board
						displayString player2Msg	; prompt player 2
 000000AA  52		     1		push	edx
 000000AB  BA 000001FB R     1		mov		edx, OFFSET player2Msg
 000000B0  E8 00000000 E     1		call	WriteString
 000000B5  5A		     1		pop		edx
 000000B6  E8 0000050F				call	getMoveO			; player 2 makes a move
						; check if board is full or someone won
 000000BB  68 00000413 R			push	OFFSET player1Wins  ; number of times player 1 has won
 000000C0  68 00000417 R			push	OFFSET player2Wins	; number of times player 2 has won
 000000C5  68 0000041B R			push	OFFSET gameIsOver	; bool if game is over
 000000CA  E8 00000A0D				call	checkGameWin		; check if someone won
 000000CF  83 3D 0000041B R			cmp		gameIsOver, 1		; check if player 2 has won
	   01
 000000D6  0F 84 000000AB			je		endLoop				; then exit game
 000000DC  68 0000041B R			push	OFFSET gameIsOver	; bool if game is over
 000000E1  E8 000007E9				call	checkBoardFull		; check if there are no possible moves left
 000000E6  83 3D 0000041B R			cmp		gameIsOver, 0		; check if board not full and someone not won
	   00
 000000ED  0F 84 FFFFFF64			je		player1Start		; if not over then player 1 makes a move again
 000000F3  E9 0000008F				jmp		endLoop				; exit game
					
 000000F8				cpuStart: ; human vs cpu
						; get player order
						displayString orderMsg
 000000F8  52		     1		push	edx
 000000F9  BA 0000028A R     1		mov		edx, OFFSET orderMsg
 000000FE  E8 00000000 E     1		call	WriteString
 00000103  5A		     1		pop		edx
 00000104  E8 00000000 E			call	ReadDec
 00000109  E8 00000157				call	displayBoard		; show tic tac toe board
 0000010E  83 F8 01				cmp		eax, 1				; if input is 1 then human goes first
 00000111  75 3A				jne		cpuMove				; skip human's turn
 00000113				cpuLoopStart: ; start getting moves from players
						; get player move
 00000113  E8 000002C8				call	getMoveX			; human makes a move
 00000118  E8 00000148				call	displayBoard		; update board
						; check if board full or someone won
 0000011D  68 00000413 R			push	OFFSET player1Wins  ; number of times human has won
 00000122  68 00000417 R			push	OFFSET player2Wins	; number of times cpu has won
 00000127  68 0000041B R			push	OFFSET gameIsOver	; bool if game is over
 0000012C  E8 000009AB				call	checkGameWin		; check if someone has won
 00000131  83 3D 0000041B R			cmp		gameIsOver, 1		; check if human won
	   01
 00000138  74 4D				je		endLoop				; then exit game
 0000013A  68 0000041B R			push	OFFSET gameIsOver	; bool if game is over
 0000013F  E8 0000078B				call	checkBoardFull		; check if there are no possible moves left
 00000144  83 3D 0000041B R			cmp		gameIsOver, 1		; check if board full
	   01
 0000014B  74 3A				je		endLoop				; then exit game
 0000014D				cpuMove: ; CPU makes a move
 0000014D  E8 00000662				call	getCpuMove			; CPU makes a move
 00000152  E8 0000010E				call	displayBoard		; update board
						; check if board full or someone won
 00000157  68 00000413 R			push	OFFSET player1Wins  ; number of times human has won
 0000015C  68 00000417 R			push	OFFSET player2Wins	; number of times cpu has won
 00000161  68 0000041B R			push	OFFSET gameIsOver	; bool if game is over
 00000166  E8 00000971				call	checkGameWin		; check if someone won
 0000016B  83 3D 0000041B R			cmp		gameIsOver, 1		; check if cpu has won
	   01
 00000172  74 13				je		endLoop				; then exit game
 00000174  68 0000041B R			push	OFFSET gameIsOver	; bool if game is over
 00000179  E8 00000751				call	checkBoardFull		; check if there are no possible moves left
 0000017E  83 3D 0000041B R			cmp		gameIsOver, 0		; check if board not full and someone not won
	   00
 00000185  74 8C				je		cpuLoopStart		; then human makes a move again

 00000187				endLoop: ; a game has ended
					; check if someone has won a best 2 out of 3
 00000187  83 3D 00000413 R		cmp		player1Wins, 2	 ; if player 1 has two wins
	   02
 0000018E  74 29			je		player1Victory	 ; then jump to their victory message
 00000190  83 3D 00000417 R		cmp		player2Wins, 2	 ; if player 2 has two wins
	   02
 00000197  74 2E			je		player2Victory	 ; then jump to their victory message
					displayString rematchMsg ; alert player that another game is starting
 00000199  52		     1		push	edx
 0000019A  BA 000002CD R     1		mov		edx, OFFSET rematchMsg
 0000019F  E8 00000000 E     1		call	WriteString
 000001A4  5A		     1		pop		edx
 000001A5  E8 00000000 E		call	CrLf
 000001AA  68 0000041B R		push	OFFSET gameIsOver ; bool to end game or not
 000001AF  E8 00000DB9			call	resetGame		  ; reset board values
 000001B4  E9 FFFFFE7B			jmp		rematch			  ; start another game of the same game mode

 000001B9				player1Victory:			 ; player 1 wins
					displayString player1Won ; congrats message
 000001B9  52		     1		push	edx
 000001BA  BA 000002EA R     1		mov		edx, OFFSET player1Won
 000001BF  E8 00000000 E     1		call	WriteString
 000001C4  5A		     1		pop		edx
 000001C5  EB 0C			jmp		askAgain		 ; jump to ask if they want to play again
 000001C7				player2Victory:			 ; player 2 wins
					displayString player2Won ; congrats message
 000001C7  52		     1		push	edx
 000001C8  BA 00000318 R     1		mov		edx, OFFSET player2Won
 000001CD  E8 00000000 E     1		call	WriteString
 000001D2  5A		     1		pop		edx

 000001D3				askAgain:
 000001D3  68 0000041F R		push	OFFSET againBool ; if user wants to play again
 000001D8  E8 00000D4E			call	playAgain		 ; ask user if they want to play again
 000001DD  83 3D 0000041F R		cmp		againBool, 1	 ; 1 to play again
	   01
 000001E4  75 19			jne		goodbyeLabel	 ; end program
 000001E6  C7 05 00000413 R		mov		player1Wins, 0	 ; reset win counter
	   00000000
 000001F0  C7 05 00000417 R		mov		player2Wins, 0	 ; reset win counter
	   00000000
 000001FA  E9 FFFFFE0B			jmp		startAgain		 ; back to beginning

 000001FF				goodbyeLabel:
 000001FF  E8 00000E13			call	goodbye			 ; say goodbye
					exit					 ; exit to operating system
 00000204  6A 00	   *	    push   +000000000h
 00000206  E8 00000000 E   *	    call   ExitProcess
 0000020B			main ENDP

				;---------------------------------------------------
				; greets user and gives description of program
				;
				; registers used: edx, ecx
				; Receives: address of username
				; Returns: username
				;---------------------------------------------------
 0000020B			introduction	PROC
 0000020B  55				push	ebp
 0000020C  8B EC			mov		ebp, esp
					; display author's name and title of project
					displayString welcomeMsg
 0000020E  52		     1		push	edx
 0000020F  BA 00000000 R     1		mov		edx, OFFSET welcomeMsg
 00000214  E8 00000000 E     1		call	WriteString
 00000219  5A		     1		pop		edx
 0000021A  E8 00000000 E		call	CrLf

					; get name and greet user with a max of 100 char
					displayString getName		 ; prompt user
 0000021F  52		     1		push	edx
 00000220  BA 00000035 R     1		mov		edx, OFFSET getName
 00000225  E8 00000000 E     1		call	WriteString
 0000022A  5A		     1		pop		edx
 0000022B  8B 55 08			mov		edx, [ebp+8]		 ; userName to edx
 0000022E  B9 00000065			mov		ecx, MAX_LENGTH_NAME ; max length of name
 00000233  E8 00000000 E		call	ReadString
					; greet user
					displayString greetMsg1
 00000238  52		     1		push	edx
 00000239  BA 0000004E R     1		mov		edx, OFFSET greetMsg1
 0000023E  E8 00000000 E     1		call	WriteString
 00000243  5A		     1		pop		edx
					displayString userName
 00000244  52		     1		push	edx
 00000245  BA 000003AD R     1		mov		edx, OFFSET userName
 0000024A  E8 00000000 E     1		call	WriteString
 0000024F  5A		     1		pop		edx
					displayString greetMsg2
 00000250  52		     1		push	edx
 00000251  BA 00000056 R     1		mov		edx, OFFSET greetMsg2
 00000256  E8 00000000 E     1		call	WriteString
 0000025B  5A		     1		pop		edx
 0000025C  E8 00000000 E		call	CrLf
 00000261  5D				pop		ebp
 00000262  C2 0004			ret		4
 00000265			introduction	ENDP

				;---------------------------------------------------
				; outputs the tic tac toe board
				;
				; registers used: edx
				; Receives: nothing
				; Returns: nothing
				;---------------------------------------------------
 00000265			displayBoard	PROC
					; boardLines are the edges of the board
					; spaces are blanks, X, and O
 00000265  E8 00000000 E		call	Clrscr			; clear screen
					; line 1
					displayString boardLine1
 0000026A  52		     1		push	edx
 0000026B  BA 0000038B R     1		mov		edx, OFFSET boardLine1
 00000270  E8 00000000 E     1		call	WriteString
 00000275  5A		     1		pop		edx
					; line 2
					displayString boardLine214
 00000276  52		     1		push	edx
 00000277  BA 00000399 R     1		mov		edx, OFFSET boardLine214
 0000027C  E8 00000000 E     1		call	WriteString
 00000281  5A		     1		pop		edx
					displayString space7
 00000282  52		     1		push	edx
 00000283  BA 00000437 R     1		mov		edx, OFFSET space7
 00000288  E8 00000000 E     1		call	WriteString
 0000028D  5A		     1		pop		edx
					displayString boardLine223
 0000028E  52		     1		push	edx
 0000028F  BA 0000039B R     1		mov		edx, OFFSET boardLine223
 00000294  E8 00000000 E     1		call	WriteString
 00000299  5A		     1		pop		edx
					displayString space8
 0000029A  52		     1		push	edx
 0000029B  BA 00000439 R     1		mov		edx, OFFSET space8
 000002A0  E8 00000000 E     1		call	WriteString
 000002A5  5A		     1		pop		edx
					displayString boardLine223
 000002A6  52		     1		push	edx
 000002A7  BA 0000039B R     1		mov		edx, OFFSET boardLine223
 000002AC  E8 00000000 E     1		call	WriteString
 000002B1  5A		     1		pop		edx
					displayString space9
 000002B2  52		     1		push	edx
 000002B3  BA 0000043B R     1		mov		edx, OFFSET space9
 000002B8  E8 00000000 E     1		call	WriteString
 000002BD  5A		     1		pop		edx
					displayString boardLine214
 000002BE  52		     1		push	edx
 000002BF  BA 00000399 R     1		mov		edx, OFFSET boardLine214
 000002C4  E8 00000000 E     1		call	WriteString
 000002C9  5A		     1		pop		edx
 000002CA  E8 00000000 E		call	CrLf
					; line 3
					displayString boardLine1
 000002CF  52		     1		push	edx
 000002D0  BA 0000038B R     1		mov		edx, OFFSET boardLine1
 000002D5  E8 00000000 E     1		call	WriteString
 000002DA  5A		     1		pop		edx
					; line 4
					displayString boardLine4
 000002DB  52		     1		push	edx
 000002DC  BA 0000039F R     1		mov		edx, OFFSET boardLine4
 000002E1  E8 00000000 E     1		call	WriteString
 000002E6  5A		     1		pop		edx
					; line 5
					displayString boardLine1
 000002E7  52		     1		push	edx
 000002E8  BA 0000038B R     1		mov		edx, OFFSET boardLine1
 000002ED  E8 00000000 E     1		call	WriteString
 000002F2  5A		     1		pop		edx
					; line 6
					displayString boardLine214
 000002F3  52		     1		push	edx
 000002F4  BA 00000399 R     1		mov		edx, OFFSET boardLine214
 000002F9  E8 00000000 E     1		call	WriteString
 000002FE  5A		     1		pop		edx
					displayString space4
 000002FF  52		     1		push	edx
 00000300  BA 00000431 R     1		mov		edx, OFFSET space4
 00000305  E8 00000000 E     1		call	WriteString
 0000030A  5A		     1		pop		edx
					displayString boardLine223
 0000030B  52		     1		push	edx
 0000030C  BA 0000039B R     1		mov		edx, OFFSET boardLine223
 00000311  E8 00000000 E     1		call	WriteString
 00000316  5A		     1		pop		edx
					displayString space5
 00000317  52		     1		push	edx
 00000318  BA 00000433 R     1		mov		edx, OFFSET space5
 0000031D  E8 00000000 E     1		call	WriteString
 00000322  5A		     1		pop		edx
					displayString boardLine223
 00000323  52		     1		push	edx
 00000324  BA 0000039B R     1		mov		edx, OFFSET boardLine223
 00000329  E8 00000000 E     1		call	WriteString
 0000032E  5A		     1		pop		edx
					displayString space6
 0000032F  52		     1		push	edx
 00000330  BA 00000435 R     1		mov		edx, OFFSET space6
 00000335  E8 00000000 E     1		call	WriteString
 0000033A  5A		     1		pop		edx
					displayString boardLine214
 0000033B  52		     1		push	edx
 0000033C  BA 00000399 R     1		mov		edx, OFFSET boardLine214
 00000341  E8 00000000 E     1		call	WriteString
 00000346  5A		     1		pop		edx
 00000347  E8 00000000 E		call	CrLf
					; line 7
					displayString boardLine1
 0000034C  52		     1		push	edx
 0000034D  BA 0000038B R     1		mov		edx, OFFSET boardLine1
 00000352  E8 00000000 E     1		call	WriteString
 00000357  5A		     1		pop		edx
					; line 8
					displayString boardLine4
 00000358  52		     1		push	edx
 00000359  BA 0000039F R     1		mov		edx, OFFSET boardLine4
 0000035E  E8 00000000 E     1		call	WriteString
 00000363  5A		     1		pop		edx
					; line 9
					displayString boardLine1
 00000364  52		     1		push	edx
 00000365  BA 0000038B R     1		mov		edx, OFFSET boardLine1
 0000036A  E8 00000000 E     1		call	WriteString
 0000036F  5A		     1		pop		edx
					; line 10
					displayString boardLine214
 00000370  52		     1		push	edx
 00000371  BA 00000399 R     1		mov		edx, OFFSET boardLine214
 00000376  E8 00000000 E     1		call	WriteString
 0000037B  5A		     1		pop		edx
					displayString space1
 0000037C  52		     1		push	edx
 0000037D  BA 0000042B R     1		mov		edx, OFFSET space1
 00000382  E8 00000000 E     1		call	WriteString
 00000387  5A		     1		pop		edx
					displayString boardLine223
 00000388  52		     1		push	edx
 00000389  BA 0000039B R     1		mov		edx, OFFSET boardLine223
 0000038E  E8 00000000 E     1		call	WriteString
 00000393  5A		     1		pop		edx
					displayString space2
 00000394  52		     1		push	edx
 00000395  BA 0000042D R     1		mov		edx, OFFSET space2
 0000039A  E8 00000000 E     1		call	WriteString
 0000039F  5A		     1		pop		edx
					displayString boardLine223
 000003A0  52		     1		push	edx
 000003A1  BA 0000039B R     1		mov		edx, OFFSET boardLine223
 000003A6  E8 00000000 E     1		call	WriteString
 000003AB  5A		     1		pop		edx
					displayString space3
 000003AC  52		     1		push	edx
 000003AD  BA 0000042F R     1		mov		edx, OFFSET space3
 000003B2  E8 00000000 E     1		call	WriteString
 000003B7  5A		     1		pop		edx
					displayString boardLine214
 000003B8  52		     1		push	edx
 000003B9  BA 00000399 R     1		mov		edx, OFFSET boardLine214
 000003BE  E8 00000000 E     1		call	WriteString
 000003C3  5A		     1		pop		edx
 000003C4  E8 00000000 E		call	CrLf
					; line 11
					displayString boardLine1
 000003C9  52		     1		push	edx
 000003CA  BA 0000038B R     1		mov		edx, OFFSET boardLine1
 000003CF  E8 00000000 E     1		call	WriteString
 000003D4  5A		     1		pop		edx
 000003D5  E8 00000000 E		call	CrLf
 000003DA  E8 00000000 E		call	CrLf
 000003DF  C3				ret
 000003E0			displayBoard	ENDP

				;---------------------------------------------------
				; gets an input from player X and fills the space
				;
				; registers used: edx, eax
				; Receives: nothing
				; Returns: nothing
				;---------------------------------------------------
 000003E0			getMoveX			PROC
					; local variables
					LOCAL inputMove:DWORD	; user's move

 000003E0  55		   *	    push   ebp
 000003E1  8B EC	   *	    mov    ebp, esp
 000003E3  83 C4 FC	   *	    add    esp, 0FFFFFFFCh
 000003E6				getMoveStart:			; get input for move
					displayString instrcMsg ; prompt user
 000003E6  52		     1		push	edx
 000003E7  BA 0000009A R     1		mov		edx, OFFSET instrcMsg
 000003EC  E8 00000000 E     1		call	WriteString
 000003F1  5A		     1		pop		edx
 000003F2  E8 00000000 E		call	ReadDec
 000003F7  89 45 FC			mov		inputMove, eax	; move user input to inputMove
 000003FA  E8 00000000 E		call	CrLf

					; check if valid (1-9)
 000003FF  83 7D FC 01			cmp		inputMove, 1
 00000403  0F 8C 000001A9		jl		invalidMove
 00000409  83 7D FC 09			cmp		inputMove, 9
 0000040D  0F 8F 0000019F		jg		invalidMove

					; check what user wrote and go to that space
 00000413  83 7D FC 01			cmp		inputMove, 1
 00000417  74 4C			je		xMove1
 00000419  83 7D FC 02			cmp		inputMove, 2
 0000041D  74 6C			je		xMove2
 0000041F  83 7D FC 03			cmp		inputMove, 3
 00000423  0F 84 00000088		je		xMove3
 00000429  83 7D FC 04			cmp		inputMove, 4
 0000042D  0F 84 000000A4		je		xMove4
 00000433  83 7D FC 05			cmp		inputMove, 5
 00000437  0F 84 000000C0		je		xMove5
 0000043D  83 7D FC 06			cmp		inputMove, 6
 00000441  0F 84 000000DC		je		xMove6
 00000447  83 7D FC 07			cmp		inputMove, 7
 0000044B  0F 84 000000F8		je		xMove7
 00000451  83 7D FC 08			cmp		inputMove, 8
 00000455  0F 84 00000111		je		xMove8
 0000045B  83 7D FC 09			cmp		inputMove, 9
 0000045F  0F 84 0000012A		je		xMove9

					; Player X makes a move, put X into space
 00000465				xMove1:
						; check if space is empty
 00000465  80 3D 0000042B R			cmp		space1, " "
	   20
 0000046C  75 0C				jne		filledspace1x	; this space is already full
						; if empty then fill space with X
 0000046E  C6 05 0000042B R			mov		space1, "X"
	   58
 00000475  E9 0000014E				jmp		endLabel1		; exit this procedure
						; if filled then get move again
 0000047A					filledspace1x:			; this space is already full
						displayString filledMsg
 0000047A  52		     1		push	edx
 0000047B  BA 00000214 R     1		mov		edx, OFFSET filledMsg
 00000480  E8 00000000 E     1		call	WriteString
 00000485  5A		     1		pop		edx
 00000486  E9 FFFFFF5B				jmp		getMoveStart	; get a new move

 0000048B				xMove2:
						; check if space is empty
 0000048B  80 3D 0000042D R			cmp		space2, " "
	   20
 00000492  75 0C				jne		filledspace2x	; this space is already full
						; if empty then fill space with X
 00000494  C6 05 0000042D R			mov		space2, "X"
	   58
 0000049B  E9 00000128				jmp		endLabel1		; exit this procedure
						; if filled then get move again
 000004A0					filledspace2x:			; this space is already full
						displayString filledMsg
 000004A0  52		     1		push	edx
 000004A1  BA 00000214 R     1		mov		edx, OFFSET filledMsg
 000004A6  E8 00000000 E     1		call	WriteString
 000004AB  5A		     1		pop		edx
 000004AC  E9 FFFFFF35				jmp		getMoveStart	; get a new move

 000004B1				xMove3:
						; check if space is empty
 000004B1  80 3D 0000042F R			cmp		space3, " "
	   20
 000004B8  75 0C				jne		filledspace3x	; this space is already full
						; if empty then fill space with X
 000004BA  C6 05 0000042F R			mov		space3, "X"
	   58
 000004C1  E9 00000102				jmp		endLabel1		; exit this procedure
						; if filled then get move again
 000004C6					filledspace3x:			; this space is already full
						displayString filledMsg
 000004C6  52		     1		push	edx
 000004C7  BA 00000214 R     1		mov		edx, OFFSET filledMsg
 000004CC  E8 00000000 E     1		call	WriteString
 000004D1  5A		     1		pop		edx
 000004D2  E9 FFFFFF0F				jmp		getMoveStart	; get a new move

 000004D7				xMove4:
						; check if space is empty
 000004D7  80 3D 00000431 R			cmp		space4, " "
	   20
 000004DE  75 0C				jne		filledspace4x	; this space is already full
						; if empty then fill space with X
 000004E0  C6 05 00000431 R			mov		space4, "X"
	   58
 000004E7  E9 000000DC				jmp		endLabel1		; exit this procedure
						; if filled then get move again
 000004EC					filledspace4x:			; this space is already full
						displayString filledMsg
 000004EC  52		     1		push	edx
 000004ED  BA 00000214 R     1		mov		edx, OFFSET filledMsg
 000004F2  E8 00000000 E     1		call	WriteString
 000004F7  5A		     1		pop		edx
 000004F8  E9 FFFFFEE9				jmp		getMoveStart	; get a new move

 000004FD				xMove5:
						; check if space is empty
 000004FD  80 3D 00000433 R			cmp		space5, " "
	   20
 00000504  75 0C				jne		filledspace5x	; this space is already full
						; if empty then fill space with X
 00000506  C6 05 00000433 R			mov		space5, "X"
	   58
 0000050D  E9 000000B6				jmp		endLabel1		; exit this procedure
						; if filled then get move again
 00000512					filledspace5x:			; this space is already full
						displayString filledMsg
 00000512  52		     1		push	edx
 00000513  BA 00000214 R     1		mov		edx, OFFSET filledMsg
 00000518  E8 00000000 E     1		call	WriteString
 0000051D  5A		     1		pop		edx
 0000051E  E9 FFFFFEC3				jmp		getMoveStart	; get a new move

 00000523				xMove6:
						; check if space is empty
 00000523  80 3D 00000435 R			cmp		space6, " "
	   20
 0000052A  75 0C				jne		filledspace6x	; this space is already full
						; if empty then fill space with X
 0000052C  C6 05 00000435 R			mov		space6, "X"
	   58
 00000533  E9 00000090				jmp		endLabel1		; exit this procedure
						; if filled then get move again
 00000538					filledspace6x:			; this space is already full
						displayString filledMsg
 00000538  52		     1		push	edx
 00000539  BA 00000214 R     1		mov		edx, OFFSET filledMsg
 0000053E  E8 00000000 E     1		call	WriteString
 00000543  5A		     1		pop		edx
 00000544  E9 FFFFFE9D				jmp		getMoveStart	; get a new move

 00000549				xMove7:
						; check if space is empty
 00000549  80 3D 00000437 R			cmp		space7, " "
	   20
 00000550  75 09				jne		filledspace7x	; this space is already full
						; if empty then fill space with X
 00000552  C6 05 00000437 R			mov		space7, "X"
	   58
 00000559  EB 6D				jmp		endLabel1		; exit this procedure
						; if filled then get move again
 0000055B					filledspace7x:			; this space is already full
						displayString filledMsg
 0000055B  52		     1		push	edx
 0000055C  BA 00000214 R     1		mov		edx, OFFSET filledMsg
 00000561  E8 00000000 E     1		call	WriteString
 00000566  5A		     1		pop		edx
 00000567  E9 FFFFFE7A				jmp		getMoveStart	; get a new move

 0000056C				xMove8:
						; check if space is empty
 0000056C  80 3D 00000439 R			cmp		space8, " "
	   20
 00000573  75 09				jne		filledspace8x	; this space is already full
						; if empty then fill space with X
 00000575  C6 05 00000439 R			mov		space8, "X"
	   58
 0000057C  EB 4A				jmp		endLabel1		; exit this procedure
						; if filled then get move again
 0000057E					filledspace8x:			; this space is already full
						displayString filledMsg
 0000057E  52		     1		push	edx
 0000057F  BA 00000214 R     1		mov		edx, OFFSET filledMsg
 00000584  E8 00000000 E     1		call	WriteString
 00000589  5A		     1		pop		edx
 0000058A  E9 FFFFFE57				jmp		getMoveStart	; get a new move

 0000058F				xMove9:
						; check if space is empty
 0000058F  80 3D 0000043B R			cmp		space9, " "
	   20
 00000596  75 09				jne		filledspace9x	; this space is already full
						; if empty then fill space with X
 00000598  C6 05 0000043B R			mov		space9, "X"
	   58
 0000059F  EB 27				jmp		endLabel1		; exit this procedure
						; if filled then get move again
 000005A1					filledspace9x:			; this space is already full
						displayString filledMsg
 000005A1  52		     1		push	edx
 000005A2  BA 00000214 R     1		mov		edx, OFFSET filledMsg
 000005A7  E8 00000000 E     1		call	WriteString
 000005AC  5A		     1		pop		edx
 000005AD  E9 FFFFFE34				jmp		getMoveStart	; get a new move

 000005B2				invalidMove: ; input is out of bounds
						displayString invalidMsg
 000005B2  52		     1		push	edx
 000005B3  BA 000000F2 R     1		mov		edx, OFFSET invalidMsg
 000005B8  E8 00000000 E     1		call	WriteString
 000005BD  5A		     1		pop		edx
 000005BE  E8 00000000 E			call	CrLf
 000005C3  E9 FFFFFE1E				jmp		getMoveStart ; get a new move

 000005C8				endLabel1:
					ret
 000005C8  C9		   *	    leave  
 000005C9  C3		   *	    ret    00000h
 000005CA			getMoveX			ENDP

				;---------------------------------------------------
				; gets an input from player O and fills the space
				;
				; registers used: edx, eax
				; Receives: nothing
				; Returns: nothing
				;---------------------------------------------------
 000005CA			getMoveO			PROC
					; local variables
					LOCAL inputMove:DWORD	; user's move

 000005CA  55		   *	    push   ebp
 000005CB  8B EC	   *	    mov    ebp, esp
 000005CD  83 C4 FC	   *	    add    esp, 0FFFFFFFCh
 000005D0				getMoveStartO:			; get input for move
					displayString instrcMsg ; prompt user
 000005D0  52		     1		push	edx
 000005D1  BA 0000009A R     1		mov		edx, OFFSET instrcMsg
 000005D6  E8 00000000 E     1		call	WriteString
 000005DB  5A		     1		pop		edx
 000005DC  E8 00000000 E		call	ReadDec
 000005E1  89 45 FC			mov		inputMove, eax	; move user input to inputMove
 000005E4  E8 00000000 E		call	CrLf

					; check if valid (1-9)
 000005E9  83 7D FC 01			cmp		inputMove, 1
 000005ED  0F 8C 000001A9		jl		invalidMoveO
 000005F3  83 7D FC 09			cmp		inputMove, 9
 000005F7  0F 8F 0000019F		jg		invalidMoveO

					; check what user wrote then go to respective space
 000005FD  83 7D FC 01			cmp		inputMove, 1
 00000601  74 4C			je		OMove1
 00000603  83 7D FC 02			cmp		inputMove, 2
 00000607  74 6C			je		OMove2
 00000609  83 7D FC 03			cmp		inputMove, 3
 0000060D  0F 84 00000088		je		OMove3
 00000613  83 7D FC 04			cmp		inputMove, 4
 00000617  0F 84 000000A4		je		OMove4
 0000061D  83 7D FC 05			cmp		inputMove, 5
 00000621  0F 84 000000C0		je		OMove5
 00000627  83 7D FC 06			cmp		inputMove, 6
 0000062B  0F 84 000000DC		je		OMove6
 00000631  83 7D FC 07			cmp		inputMove, 7
 00000635  0F 84 000000F8		je		OMove7
 0000063B  83 7D FC 08			cmp		inputMove, 8
 0000063F  0F 84 00000111		je		OMove8
 00000645  83 7D FC 09			cmp		inputMove, 9
 00000649  0F 84 0000012A		je		OMove9

					; Player O makes a move, put O into respective space
 0000064F				oMove1:
						; check if space is empty
 0000064F  80 3D 0000042B R			cmp		space1, " "
	   20
 00000656  75 0C				jne		filledspace1o	; this space is already full
						; if empty then set space to O
 00000658  C6 05 0000042B R			mov		space1, "O"
	   4F
 0000065F  E9 0000014E				jmp		endLabelO1		; exit this procedure
						; if filled then get move again
 00000664					filledspace1o:			; this space is already full
						displayString filledMsg
 00000664  52		     1		push	edx
 00000665  BA 00000214 R     1		mov		edx, OFFSET filledMsg
 0000066A  E8 00000000 E     1		call	WriteString
 0000066F  5A		     1		pop		edx
 00000670  E9 FFFFFF5B				jmp		getMoveStartO	; get move again

 00000675				oMove2:
						; check if space is empty
 00000675  80 3D 0000042D R			cmp		space2, " "
	   20
 0000067C  75 0C				jne		filledspace2o	; this space is already full
						; if empty then set space to O
 0000067E  C6 05 0000042D R			mov		space2, "O"
	   4F
 00000685  E9 00000128				jmp		endLabelO1		; exit this procedure
						; if filled then get move again
 0000068A					filledspace2o:			; this space is already full
						displayString filledMsg
 0000068A  52		     1		push	edx
 0000068B  BA 00000214 R     1		mov		edx, OFFSET filledMsg
 00000690  E8 00000000 E     1		call	WriteString
 00000695  5A		     1		pop		edx
 00000696  E9 FFFFFF35				jmp		getMoveStartO	; get move again

 0000069B				oMove3:
						; check if space is empty
 0000069B  80 3D 0000042F R			cmp		space3, " "
	   20
 000006A2  75 0C				jne		filledspace3o	; this space is already full
						; if empty then set space to O
 000006A4  C6 05 0000042F R			mov		space3, "O"
	   4F
 000006AB  E9 00000102				jmp		endLabelO1		; exit this procedure
						; if filled then get move again
 000006B0					filledspace3o:			; this space is already full
						displayString filledMsg
 000006B0  52		     1		push	edx
 000006B1  BA 00000214 R     1		mov		edx, OFFSET filledMsg
 000006B6  E8 00000000 E     1		call	WriteString
 000006BB  5A		     1		pop		edx
 000006BC  E9 FFFFFF0F				jmp		getMoveStartO	; get move again

 000006C1				oMove4:
						; check if space is empty
 000006C1  80 3D 00000431 R			cmp		space4, " "
	   20
 000006C8  75 0C				jne		filledspace4o	; this space is already full
						; if empty then set space to O
 000006CA  C6 05 00000431 R			mov		space4, "O"
	   4F
 000006D1  E9 000000DC				jmp		endLabelO1		; exit this procedure
						; if filled then get move again
 000006D6					filledspace4o:			; this space is already full
						displayString filledMsg
 000006D6  52		     1		push	edx
 000006D7  BA 00000214 R     1		mov		edx, OFFSET filledMsg
 000006DC  E8 00000000 E     1		call	WriteString
 000006E1  5A		     1		pop		edx
 000006E2  E9 FFFFFEE9				jmp		getMoveStartO	; get move again

 000006E7				oMove5:
						; check if space is empty
 000006E7  80 3D 00000433 R			cmp		space5, " "
	   20
 000006EE  75 0C				jne		filledspace5o	; this space is already full
						; if empty then set space to O
 000006F0  C6 05 00000433 R			mov		space5, "O"
	   4F
 000006F7  E9 000000B6				jmp		endLabelO1		; exit this procedure
						; if filled then get move again
 000006FC					filledspace5o:			; this space is already full
						displayString filledMsg
 000006FC  52		     1		push	edx
 000006FD  BA 00000214 R     1		mov		edx, OFFSET filledMsg
 00000702  E8 00000000 E     1		call	WriteString
 00000707  5A		     1		pop		edx
 00000708  E9 FFFFFEC3				jmp		getMoveStartO	; get move again

 0000070D				oMove6:
						; check if space is empty
 0000070D  80 3D 00000435 R			cmp		space6, " "
	   20
 00000714  75 0C				jne		filledspace6o	; this space is already full
						; if empty then set space to O
 00000716  C6 05 00000435 R			mov		space6, "O"
	   4F
 0000071D  E9 00000090				jmp		endLabelO1		; exit this procedure
						; if filled then get move again
 00000722					filledspace6o:			; this space is already full
						displayString filledMsg
 00000722  52		     1		push	edx
 00000723  BA 00000214 R     1		mov		edx, OFFSET filledMsg
 00000728  E8 00000000 E     1		call	WriteString
 0000072D  5A		     1		pop		edx
 0000072E  E9 FFFFFE9D				jmp		getMoveStartO	; get move again

 00000733				oMove7:
						; check if space is empty
 00000733  80 3D 00000437 R			cmp		space7, " "
	   20
 0000073A  75 09				jne		filledspace7o	; this space is already full
						; if empty then set space to O
 0000073C  C6 05 00000437 R			mov		space7, "O"
	   4F
 00000743  EB 6D				jmp		endLabelO1		; exit this procedure
						; if filled then get move again
 00000745					filledspace7o:			; this space is already full
						displayString filledMsg
 00000745  52		     1		push	edx
 00000746  BA 00000214 R     1		mov		edx, OFFSET filledMsg
 0000074B  E8 00000000 E     1		call	WriteString
 00000750  5A		     1		pop		edx
 00000751  E9 FFFFFE7A				jmp		getMoveStartO	; get move again

 00000756				oMove8:
						; check if space is empty
 00000756  80 3D 00000439 R			cmp		space8, " "
	   20
 0000075D  75 09				jne		filledspace8o	; this space is already full
						; if empty then set space to O
 0000075F  C6 05 00000439 R			mov		space8, "O"
	   4F
 00000766  EB 4A				jmp		endLabelO1		; exit this procedure
						; if filled then get move again
 00000768					filledspace8o:			; this space is already full
						displayString filledMsg
 00000768  52		     1		push	edx
 00000769  BA 00000214 R     1		mov		edx, OFFSET filledMsg
 0000076E  E8 00000000 E     1		call	WriteString
 00000773  5A		     1		pop		edx
 00000774  E9 FFFFFE57				jmp		getMoveStartO	; get move again

 00000779				oMove9:
						; check if space is empty
 00000779  80 3D 0000043B R			cmp		space9, " "
	   20
 00000780  75 09				jne		filledspace9o	; this space is already full
						; if empty then set space to O
 00000782  C6 05 0000043B R			mov		space9, "O"
	   4F
 00000789  EB 27				jmp		endLabelO1		; exit this procedure
						; if filled then get move again
 0000078B					filledspace9o:			; this space is already full
						displayString filledMsg
 0000078B  52		     1		push	edx
 0000078C  BA 00000214 R     1		mov		edx, OFFSET filledMsg
 00000791  E8 00000000 E     1		call	WriteString
 00000796  5A		     1		pop		edx
 00000797  E9 FFFFFE34				jmp		getMoveStartO	; get move again

 0000079C				invalidMoveO: ; input is out of bounds
						displayString invalidMsg
 0000079C  52		     1		push	edx
 0000079D  BA 000000F2 R     1		mov		edx, OFFSET invalidMsg
 000007A2  E8 00000000 E     1		call	WriteString
 000007A7  5A		     1		pop		edx
 000007A8  E8 00000000 E			call	CrLf
 000007AD  E9 FFFFFE1E				jmp		getMoveStartO ; get move again

 000007B2				endLabelO1: ; exit procedure
					ret
 000007B2  C9		   *	    leave  
 000007B3  C3		   *	    ret    00000h
 000007B4			getMoveO			ENDP

				;---------------------------------------------------
				; makes a random move for the cpu and fills the space
				;
				; registers used: edx, eax
				; Receives: nothing
				; Returns: nothing
				;---------------------------------------------------
 000007B4			getCpuMove			PROC
					; pick a random number from 1-9
					; then check if it is a valid move
 000007B4				getRandomNum:		; start of loop for getting random numbers
 000007B4  B8 00000009			mov		eax, 9		; max of 9
 000007B9  E8 00000000 E		call	randomRange ; get random number
 000007BE  40				inc		eax			; min of 1
					
					; check what cpu chose and go to that space
 000007BF  83 F8 01			cmp		eax, 1
 000007C2  74 38			je		space1CPU
 000007C4  83 F8 02			cmp		eax, 2
 000007C7  74 48			je		space2CPU
 000007C9  83 F8 03			cmp		eax, 3
 000007CC  74 58			je		space3CPU
 000007CE  83 F8 04			cmp		eax, 4
 000007D1  74 68			je		space4CPU
 000007D3  83 F8 05			cmp		eax, 5
 000007D6  74 79			je		space5CPU
 000007D8  83 F8 06			cmp		eax, 6
 000007DB  0F 84 00000086		je		space6CPU
 000007E1  83 F8 07			cmp		eax, 7
 000007E4  0F 84 00000093		je		space7CPU
 000007EA  83 F8 08			cmp		eax, 8
 000007ED  0F 84 000000A0		je		space8CPU
 000007F3  83 F8 09			cmp		eax, 9
 000007F6  0F 84 000000AD		je		space9CPU

					; check if the space is blank
					; if not get a new number, if it is then put O in it and exit procedure
 000007FC				space1CPU:
 000007FC  80 3D 0000042B R		cmp		space1, " "
	   20
 00000803  75 AF			jne		getRandomNum
 00000805  C6 05 0000042B R		mov		space1, "O"
	   4F
 0000080C  E9 000000AC			jmp		cpuEnd ; end procedure
 00000811				space2CPU:
 00000811  80 3D 0000042D R		cmp		space2, " "
	   20
 00000818  75 9A			jne		getRandomNum
 0000081A  C6 05 0000042D R		mov		space2, "O"
	   4F
 00000821  E9 00000097			jmp		cpuEnd ; end procedure
 00000826				space3CPU:
 00000826  80 3D 0000042F R		cmp		space3, " "
	   20
 0000082D  75 85			jne		getRandomNum
 0000082F  C6 05 0000042F R		mov		space3, "O"
	   4F
 00000836  E9 00000082			jmp		cpuEnd ; end procedure
 0000083B				space4CPU:
 0000083B  80 3D 00000431 R		cmp		space4, " "
	   20
 00000842  0F 85 FFFFFF6C		jne		getRandomNum
 00000848  C6 05 00000431 R		mov		space4, "O"
	   4F
 0000084F  EB 6C			jmp		cpuEnd ; end procedure
 00000851				space5CPU:
 00000851  80 3D 00000433 R		cmp		space5, " "
	   20
 00000858  0F 85 FFFFFF56		jne		getRandomNum
 0000085E  C6 05 00000433 R		mov		space5, "O"
	   4F
 00000865  EB 56			jmp		cpuEnd ; end procedure
 00000867				space6CPU:
 00000867  80 3D 00000435 R		cmp		space6, " "
	   20
 0000086E  0F 85 FFFFFF40		jne		getRandomNum
 00000874  C6 05 00000435 R		mov		space6, "O"
	   4F
 0000087B  EB 40			jmp		cpuEnd ; end procedure
 0000087D				space7CPU:
 0000087D  80 3D 00000437 R		cmp		space7, " "
	   20
 00000884  0F 85 FFFFFF2A		jne		getRandomNum
 0000088A  C6 05 00000437 R		mov		space7, "O"
	   4F
 00000891  EB 2A			jmp		cpuEnd ; end procedure
 00000893				space8CPU:
 00000893  80 3D 00000439 R		cmp		space8, " "
	   20
 0000089A  0F 85 FFFFFF14		jne		getRandomNum
 000008A0  C6 05 00000439 R		mov		space8, "O"
	   4F
 000008A7  EB 14			jmp		cpuEnd ; end procedure
 000008A9				space9CPU:
 000008A9  80 3D 0000043B R		cmp		space9, " "
	   20
 000008B0  0F 85 FFFFFEFE		jne		getRandomNum
 000008B6  C6 05 0000043B R		mov		space9, "O"
	   4F

 000008BD				cpuEnd: ; end procedure
					displayString cpuMsg
 000008BD  52		     1		push	edx
 000008BE  BA 00000268 R     1		mov		edx, OFFSET cpuMsg
 000008C3  E8 00000000 E     1		call	WriteString
 000008C8  5A		     1		pop		edx
 000008C9  E8 00000000 E		call	CrLf
 000008CE  C3				ret
 000008CF			getCpuMove			ENDP
				;---------------------------------------------------
				; checks if board is full
				;
				; registers used: ebp, esp, ebx, eax
				; Receives: address of gameIsOver
				; Returns: gameIsOver
				;---------------------------------------------------
 000008CF			checkBoardFull	PROC
 000008CF  55				push	ebp
 000008D0  8B EC			mov		ebp, esp
					; check if pieces are present in the respective space
					; if there is, then set the bool for that space to true
 000008D2				space1Check: ; space 1
 000008D2  80 3D 0000042B R			cmp		space1, "X"
	   58
 000008D9  0F 84 00000172			je		space1Full
 000008DF  80 3D 0000042B R			cmp		space1, "O"
	   4F
 000008E6  0F 84 00000165			je		space1Full
 000008EC				space2Check: ; space 2
 000008EC  80 3D 0000042D R			cmp		space2, "X"
	   58
 000008F3  0F 84 00000167			je		space2Full
 000008F9  80 3D 0000042D R			cmp		space2, "O"
	   4F
 00000900  0F 84 0000015A			je		space2Full
 00000906				space3Check: ; space 3
 00000906  80 3D 0000042F R			cmp		space3, "X"
	   58
 0000090D  0F 84 0000015C			je		space3Full
 00000913  80 3D 0000042F R			cmp		space3, "O"
	   4F
 0000091A  0F 84 0000014F			je		space3Full
 00000920				space4Check: ; space 4
 00000920  80 3D 00000431 R			cmp		space4, "X"
	   58
 00000927  0F 84 00000151			je		space4Full
 0000092D  80 3D 00000431 R			cmp		space4, "O"
	   4F
 00000934  0F 84 00000144			je		space4Full
 0000093A				space5Check: ; space 5
 0000093A  80 3D 00000433 R			cmp		space5, "X"
	   58
 00000941  0F 84 00000146			je		space5Full
 00000947  80 3D 00000433 R			cmp		space5, "O"
	   4F
 0000094E  0F 84 00000139			je		space5Full
 00000954				space6Check: ; space 6
 00000954  80 3D 00000435 R			cmp		space6, "X"
	   58
 0000095B  0F 84 0000013B			je		space6Full
 00000961  80 3D 00000435 R			cmp		space6, "O"
	   4F
 00000968  0F 84 0000012E			je		space6Full
 0000096E				space7Check: ; space 7
 0000096E  80 3D 00000437 R			cmp		space7, "X"
	   58
 00000975  0F 84 00000130			je		space7Full
 0000097B  80 3D 00000437 R			cmp		space7, "O"
	   4F
 00000982  0F 84 00000123			je		space7Full
 00000988				space8Check: ; space 8
 00000988  80 3D 00000439 R			cmp		space8, "X"
	   58
 0000098F  0F 84 00000125			je		space8Full
 00000995  80 3D 00000439 R			cmp		space8, "O"
	   4F
 0000099C  0F 84 00000118			je		space8Full
 000009A2				space9Check: ; space 9
 000009A2  80 3D 0000043B R			cmp		space9, "X"
	   58
 000009A9  0F 84 0000011A			je		space9Full
 000009AF  80 3D 0000043B R			cmp		space9, "O"
	   4F
 000009B6  0F 84 0000010D			je		space9Full
 000009BC				space10Check: ; exit for space 9, here for consistency
					
					; check if all 9 pieces are filled
					; if a space is not filled, then skip
 000009BC  83 3D 0000043D R		cmp		space1Bool, 1
	   01
 000009C3  0F 85 0000010F		jne		endLabel2
 000009C9  83 3D 00000441 R		cmp		space2Bool, 1
	   01
 000009D0  0F 85 00000102		jne		endLabel2
 000009D6  83 3D 00000445 R		cmp		space3Bool, 1
	   01
 000009DD  0F 85 000000F5		jne		endLabel2
 000009E3  83 3D 00000449 R		cmp		space4Bool, 1
	   01
 000009EA  0F 85 000000E8		jne		endLabel2
 000009F0  83 3D 0000044D R		cmp		space5Bool, 1
	   01
 000009F7  0F 85 000000DB		jne		endLabel2
 000009FD  83 3D 00000451 R		cmp		space6Bool, 1
	   01
 00000A04  0F 85 000000CE		jne		endLabel2
 00000A0A  83 3D 00000455 R		cmp		space7Bool, 1
	   01
 00000A11  0F 85 000000C1		jne		endLabel2
 00000A17  83 3D 00000459 R		cmp		space8Bool, 1
	   01
 00000A1E  0F 85 000000B4		jne		endLabel2
 00000A24  83 3D 0000045D R		cmp		space9Bool, 1
	   01
 00000A2B  0F 85 000000A7		jne		endLabel2
					
					; set bool of gameIsOver to 1
 00000A31  8B 5D 08			mov		ebx, [ebp+8] ; gameIsOver to ebx
 00000A34  B8 00000001			mov		eax, 1
 00000A39  89 03			mov		[ebx], eax	 ; 1 to gameIsOver
 00000A3B  E8 FFFFF825			call	displayBoard
					displayString tieMsg ; stalemate message
 00000A40  52		     1		push	edx
 00000A41  BA 0000025B R     1		mov		edx, OFFSET tieMsg
 00000A46  E8 00000000 E     1		call	WriteString
 00000A4B  5A		     1		pop		edx
 00000A4C  E9 00000087			jmp		endLabel2

					; check if spaces are occupied
					; if true then set bool to true and check next space
 00000A51				space1Full:
 00000A51  C7 05 0000043D R			mov		space1Bool, 1
	   00000001
 00000A5B  E9 FFFFFE8C				jmp		space2Check
 00000A60				space2Full:
 00000A60  C7 05 00000441 R			mov		space2Bool, 1
	   00000001
 00000A6A  E9 FFFFFE97				jmp		space3Check
 00000A6F				space3Full:
 00000A6F  C7 05 00000445 R			mov		space3Bool, 1
	   00000001
 00000A79  E9 FFFFFEA2				jmp		space4Check
 00000A7E				space4Full:
 00000A7E  C7 05 00000449 R			mov		space4Bool, 1
	   00000001
 00000A88  E9 FFFFFEAD				jmp		space5Check
 00000A8D				space5Full:
 00000A8D  C7 05 0000044D R			mov		space5Bool, 1
	   00000001
 00000A97  E9 FFFFFEB8				jmp		space6Check
 00000A9C				space6Full:
 00000A9C  C7 05 00000451 R			mov		space6Bool, 1
	   00000001
 00000AA6  E9 FFFFFEC3				jmp		space7Check
 00000AAB				space7Full:
 00000AAB  C7 05 00000455 R			mov		space7Bool, 1
	   00000001
 00000AB5  E9 FFFFFECE				jmp		space8Check
 00000ABA				space8Full:
 00000ABA  C7 05 00000459 R			mov		space8Bool, 1
	   00000001
 00000AC4  E9 FFFFFED9				jmp		space9Check
 00000AC9				space9Full:
 00000AC9  C7 05 0000045D R			mov		space9Bool, 1
	   00000001
 00000AD3  E9 FFFFFEE4				jmp		space10Check

 00000AD8				endLabel2: ; exit procedure
 00000AD8  5D				pop		ebp
 00000AD9  C2 0004			ret		4
 00000ADC			checkBoardFull	ENDP

				;---------------------------------------------------
				; checks if a player has won
				;
				; registers used: ebp, esp
				; Receives: address of gameIsOver
				; Returns: gameIsOver
				;---------------------------------------------------
 00000ADC			checkGameWin	PROC
 00000ADC  55				push	ebp
 00000ADD  8B EC			mov		ebp, esp

					; check bottom row X, if not 3 in a row then check next
 00000ADF  80 3D 0000042B R		cmp		space1, "X"
	   58
 00000AE6  75 3C			jne		oBottom
 00000AE8  80 3D 0000042D R		cmp		space2, "X"
	   58
 00000AEF  75 33			jne		oBottom
 00000AF1  80 3D 0000042F R		cmp		space3, "X"
	   58
 00000AF8  75 2A			jne		oBottom
 00000AFA  8B 5D 08			mov		ebx, [ebp+8] ; gameIsOver to ebx
 00000AFD  B8 00000001			mov		eax, 1
 00000B02  89 03			mov		[ebx], eax	 ; 1 to gameIsOver
 00000B04  E8 FFFFF75C			call	displayBoard ; update board
 00000B09  8B 5D 10			mov		ebx, [ebp+16]; player1wins to ebx
 00000B0C  B8 00000001			mov		eax, 1
 00000B11  01 03			add		[ebx], eax	 ; increase player1wins by one
					displayString xWinMsg
 00000B13  52		     1		push	edx
 00000B14  BA 00000233 R     1		mov		edx, OFFSET xWinMsg
 00000B19  E8 00000000 E     1		call	WriteString
 00000B1E  5A		     1		pop		edx
 00000B1F  E9 00000403			jmp		gameEnd		 ; end procedure

 00000B24				oBottom: ; check bottom row O, if not 3 in a row then check next
 00000B24  80 3D 0000042B R		cmp		space1, "O"
	   4F
 00000B2B  75 3C			jne		xMid
 00000B2D  80 3D 0000042D R		cmp		space2, "O"
	   4F
 00000B34  75 33			jne		xMid
 00000B36  80 3D 0000042F R		cmp		space3, "O"
	   4F
 00000B3D  75 2A			jne		xMid
 00000B3F  8B 5D 08			mov		ebx, [ebp+8] ; gameIsOver to ebx
 00000B42  B8 00000001			mov		eax, 1
 00000B47  89 03			mov		[ebx], eax	 ; 1 to gameIsOver
 00000B49  E8 FFFFF717			call	displayBoard ; update board
 00000B4E  8B 5D 0C			mov		ebx, [ebp+12]; player2wins to ebx
 00000B51  B8 00000001			mov		eax, 1
 00000B56  01 03			add		[ebx], eax	 ; increase player2wins by one
					displayString oWinMsg
 00000B58  52		     1		push	edx
 00000B59  BA 00000247 R     1		mov		edx, OFFSET oWinMsg
 00000B5E  E8 00000000 E     1		call	WriteString
 00000B63  5A		     1		pop		edx
 00000B64  E9 000003BE			jmp		gameEnd		 ; end procedure

 00000B69				xMid: ; check middle row X, if not 3 in a row then check next
 00000B69  80 3D 00000431 R		cmp		space4, "X"
	   58
 00000B70  75 3C			jne		oMid
 00000B72  80 3D 00000433 R		cmp		space5, "X"
	   58
 00000B79  75 33			jne		oMid
 00000B7B  80 3D 00000435 R		cmp		space6, "X"
	   58
 00000B82  75 2A			jne		oMid
 00000B84  8B 5D 08			mov		ebx, [ebp+8] ; gameIsOver to ebx
 00000B87  B8 00000001			mov		eax, 1
 00000B8C  89 03			mov		[ebx], eax	 ; 1 to gameIsOver
 00000B8E  E8 FFFFF6D2			call	displayBoard ; update board
 00000B93  8B 5D 10			mov		ebx, [ebp+16]; player1wins to ebx
 00000B96  B8 00000001			mov		eax, 1
 00000B9B  01 03			add		[ebx], eax	 ; increase player1wins by one
					displayString xWinMsg
 00000B9D  52		     1		push	edx
 00000B9E  BA 00000233 R     1		mov		edx, OFFSET xWinMsg
 00000BA3  E8 00000000 E     1		call	WriteString
 00000BA8  5A		     1		pop		edx
 00000BA9  E9 00000379			jmp		gameEnd		 ; end procedure

 00000BAE				oMid: ; check middle row O, if not 3 in a row then check next
 00000BAE  80 3D 00000431 R		cmp		space4, "O"
	   4F
 00000BB5  75 3C			jne		xTop
 00000BB7  80 3D 00000433 R		cmp		space5, "O"
	   4F
 00000BBE  75 33			jne		xTop
 00000BC0  80 3D 00000435 R		cmp		space6, "O"
	   4F
 00000BC7  75 2A			jne		xTop
 00000BC9  8B 5D 08			mov		ebx, [ebp+8] ; gameIsOver to ebx
 00000BCC  B8 00000001			mov		eax, 1
 00000BD1  89 03			mov		[ebx], eax	 ; 1 to gameIsOver
 00000BD3  E8 FFFFF68D			call	displayBoard ; update board
 00000BD8  8B 5D 0C			mov		ebx, [ebp+12]; player2wins to ebx
 00000BDB  B8 00000001			mov		eax, 1
 00000BE0  01 03			add		[ebx], eax	 ; increase player2wins by one
					displayString oWinMsg
 00000BE2  52		     1		push	edx
 00000BE3  BA 00000247 R     1		mov		edx, OFFSET oWinMsg
 00000BE8  E8 00000000 E     1		call	WriteString
 00000BED  5A		     1		pop		edx
 00000BEE  E9 00000334			jmp		gameEnd		 ; end procedure

 00000BF3				xTop: ; check top row X, if not 3 in a row then check next
 00000BF3  80 3D 00000437 R		cmp		space7, "X"
	   58
 00000BFA  75 3C			jne		oTop
 00000BFC  80 3D 00000439 R		cmp		space8, "X"
	   58
 00000C03  75 33			jne		oTop
 00000C05  80 3D 0000043B R		cmp		space9, "X"
	   58
 00000C0C  75 2A			jne		oTop
 00000C0E  8B 5D 08			mov		ebx, [ebp+8] ; gameIsOver to ebx
 00000C11  B8 00000001			mov		eax, 1
 00000C16  89 03			mov		[ebx], eax	 ; 1 to gameIsOver
 00000C18  E8 FFFFF648			call	displayBoard ; update board
 00000C1D  8B 5D 10			mov		ebx, [ebp+16]; player1wins to ebx
 00000C20  B8 00000001			mov		eax, 1
 00000C25  01 03			add		[ebx], eax	 ; increase player1wins by one
					displayString xWinMsg
 00000C27  52		     1		push	edx
 00000C28  BA 00000233 R     1		mov		edx, OFFSET xWinMsg
 00000C2D  E8 00000000 E     1		call	WriteString
 00000C32  5A		     1		pop		edx
 00000C33  E9 000002EF			jmp		gameEnd		 ; end procedure

 00000C38				oTop: ; check top row O, if not 3 in a row then check next
 00000C38  80 3D 00000437 R		cmp		space7, "O"
	   4F
 00000C3F  75 3C			jne		xCol1
 00000C41  80 3D 00000439 R		cmp		space8, "O"
	   4F
 00000C48  75 33			jne		xCol1
 00000C4A  80 3D 0000043B R		cmp		space9, "O"
	   4F
 00000C51  75 2A			jne		xCol1
 00000C53  8B 5D 08			mov		ebx, [ebp+8] ; gameIsOver to ebx
 00000C56  B8 00000001			mov		eax, 1
 00000C5B  89 03			mov		[ebx], eax	 ; 1 to gameIsOver
 00000C5D  E8 FFFFF603			call	displayBoard ; update board
 00000C62  8B 5D 0C			mov		ebx, [ebp+12]; player2wins to ebx
 00000C65  B8 00000001			mov		eax, 1
 00000C6A  01 03			add		[ebx], eax	 ; increase player2wins by one
					displayString oWinMsg
 00000C6C  52		     1		push	edx
 00000C6D  BA 00000247 R     1		mov		edx, OFFSET oWinMsg
 00000C72  E8 00000000 E     1		call	WriteString
 00000C77  5A		     1		pop		edx
 00000C78  E9 000002AA			jmp		gameEnd		 ; end procedure

 00000C7D				xCol1: ; check left col X, if not 3 in a row then check next
 00000C7D  80 3D 00000437 R		cmp		space7, "X"
	   58
 00000C84  75 3C			jne		oCol1
 00000C86  80 3D 00000431 R		cmp		space4, "X"
	   58
 00000C8D  75 33			jne		oCol1
 00000C8F  80 3D 0000042B R		cmp		space1, "X"
	   58
 00000C96  75 2A			jne		oCol1
 00000C98  8B 5D 08			mov		ebx, [ebp+8] ; gameIsOver to ebx
 00000C9B  B8 00000001			mov		eax, 1
 00000CA0  89 03			mov		[ebx], eax	 ; 1 to gameIsOver
 00000CA2  E8 FFFFF5BE			call	displayBoard ; update board
 00000CA7  8B 5D 10			mov		ebx, [ebp+16]; player1wins to ebx
 00000CAA  B8 00000001			mov		eax, 1
 00000CAF  01 03			add		[ebx], eax	 ; increase player1wins by one
					displayString xWinMsg
 00000CB1  52		     1		push	edx
 00000CB2  BA 00000233 R     1		mov		edx, OFFSET xWinMsg
 00000CB7  E8 00000000 E     1		call	WriteString
 00000CBC  5A		     1		pop		edx
 00000CBD  E9 00000265			jmp		gameEnd		 ; end procedure

 00000CC2				oCol1: ; check left col O, if not 3 in a row then check next
 00000CC2  80 3D 00000437 R		cmp		space7, "O"
	   4F
 00000CC9  75 3C			jne		xCol2
 00000CCB  80 3D 00000431 R		cmp		space4, "O"
	   4F
 00000CD2  75 33			jne		xCol2
 00000CD4  80 3D 0000042B R		cmp		space1, "O"
	   4F
 00000CDB  75 2A			jne		xCol2
 00000CDD  8B 5D 08			mov		ebx, [ebp+8] ; gameIsOver to ebx
 00000CE0  B8 00000001			mov		eax, 1
 00000CE5  89 03			mov		[ebx], eax	 ; 1 to gameIsOver
 00000CE7  E8 FFFFF579			call	displayBoard ; update board
 00000CEC  8B 5D 0C			mov		ebx, [ebp+12]; player2wins to ebx
 00000CEF  B8 00000001			mov		eax, 1
 00000CF4  01 03			add		[ebx], eax	 ; increase player2wins by one
					displayString oWinMsg
 00000CF6  52		     1		push	edx
 00000CF7  BA 00000247 R     1		mov		edx, OFFSET oWinMsg
 00000CFC  E8 00000000 E     1		call	WriteString
 00000D01  5A		     1		pop		edx
 00000D02  E9 00000220			jmp		gameEnd		 ; end procedure

 00000D07				xCol2: ; check middle col X, if not 3 in a row then check next
 00000D07  80 3D 00000439 R		cmp		space8, "X"
	   58
 00000D0E  75 3C			jne		oCol2
 00000D10  80 3D 00000433 R		cmp		space5, "X"
	   58
 00000D17  75 33			jne		oCol2
 00000D19  80 3D 0000042D R		cmp		space2, "X"
	   58
 00000D20  75 2A			jne		oCol2
 00000D22  8B 5D 08			mov		ebx, [ebp+8] ; gameIsOver to ebx
 00000D25  B8 00000001			mov		eax, 1
 00000D2A  89 03			mov		[ebx], eax	 ; 1 to gameIsOver
 00000D2C  E8 FFFFF534			call	displayBoard ; update board
 00000D31  8B 5D 10			mov		ebx, [ebp+16]; player1wins to ebx
 00000D34  B8 00000001			mov		eax, 1
 00000D39  01 03			add		[ebx], eax	 ; increase player1wins by one
					displayString xWinMsg
 00000D3B  52		     1		push	edx
 00000D3C  BA 00000233 R     1		mov		edx, OFFSET xWinMsg
 00000D41  E8 00000000 E     1		call	WriteString
 00000D46  5A		     1		pop		edx
 00000D47  E9 000001DB			jmp		gameEnd		 ; end procedure

 00000D4C				oCol2: ; check middle col O, if not 3 in a row then check next
 00000D4C  80 3D 00000439 R		cmp		space8, "O"
	   4F
 00000D53  75 3C			jne		xCol3
 00000D55  80 3D 00000433 R		cmp		space5, "O"
	   4F
 00000D5C  75 33			jne		xCol3
 00000D5E  80 3D 0000042D R		cmp		space2, "O"
	   4F
 00000D65  75 2A			jne		xCol3
 00000D67  8B 5D 08			mov		ebx, [ebp+8] ; gameIsOver to ebx
 00000D6A  B8 00000001			mov		eax, 1
 00000D6F  89 03			mov		[ebx], eax	 ; 1 to gameIsOver
 00000D71  E8 FFFFF4EF			call	displayBoard ; update board
 00000D76  8B 5D 0C			mov		ebx, [ebp+12]; player2wins to ebx
 00000D79  B8 00000001			mov		eax, 1
 00000D7E  01 03			add		[ebx], eax	 ; increase player2wins by one
					displayString oWinMsg
 00000D80  52		     1		push	edx
 00000D81  BA 00000247 R     1		mov		edx, OFFSET oWinMsg
 00000D86  E8 00000000 E     1		call	WriteString
 00000D8B  5A		     1		pop		edx
 00000D8C  E9 00000196			jmp		gameEnd		 ; end procedure

 00000D91				xCol3: ; check right col X, if not 3 in a row then check next
 00000D91  80 3D 0000043B R		cmp		space9, "X"
	   58
 00000D98  75 3C			jne		oCol3
 00000D9A  80 3D 00000435 R		cmp		space6, "X"
	   58
 00000DA1  75 33			jne		oCol3
 00000DA3  80 3D 0000042F R		cmp		space3, "X"
	   58
 00000DAA  75 2A			jne		oCol3
 00000DAC  8B 5D 08			mov		ebx, [ebp+8] ; gameIsOver to ebx
 00000DAF  B8 00000001			mov		eax, 1
 00000DB4  89 03			mov		[ebx], eax	 ; 1 to gameIsOver
 00000DB6  E8 FFFFF4AA			call	displayBoard ; update board
 00000DBB  8B 5D 10			mov		ebx, [ebp+16]; player1wins to ebx
 00000DBE  B8 00000001			mov		eax, 1
 00000DC3  01 03			add		[ebx], eax	 ; increase player1wins by one
					displayString xWinMsg
 00000DC5  52		     1		push	edx
 00000DC6  BA 00000233 R     1		mov		edx, OFFSET xWinMsg
 00000DCB  E8 00000000 E     1		call	WriteString
 00000DD0  5A		     1		pop		edx
 00000DD1  E9 00000151			jmp		gameEnd		 ; end procedure

 00000DD6				oCol3: ; check right col O, if not 3 in a row then check next
 00000DD6  80 3D 0000043B R		cmp		space9, "O"
	   4F
 00000DDD  75 3C			jne		xDiag1
 00000DDF  80 3D 00000435 R		cmp		space6, "O"
	   4F
 00000DE6  75 33			jne		xDiag1
 00000DE8  80 3D 0000042F R		cmp		space3, "O"
	   4F
 00000DEF  75 2A			jne		xDiag1
 00000DF1  8B 5D 08			mov		ebx, [ebp+8] ; gameIsOver to ebx
 00000DF4  B8 00000001			mov		eax, 1
 00000DF9  89 03			mov		[ebx], eax	 ; 1 to gameIsOver
 00000DFB  E8 FFFFF465			call	displayBoard ; update board
 00000E00  8B 5D 0C			mov		ebx, [ebp+12]; player2wins to ebx
 00000E03  B8 00000001			mov		eax, 1
 00000E08  01 03			add		[ebx], eax	 ; increase player2wins by one
					displayString oWinMsg
 00000E0A  52		     1		push	edx
 00000E0B  BA 00000247 R     1		mov		edx, OFFSET oWinMsg
 00000E10  E8 00000000 E     1		call	WriteString
 00000E15  5A		     1		pop		edx
 00000E16  E9 0000010C			jmp		gameEnd		 ; end procedure

 00000E1B				xDiag1: ; check first diagonal X, if not 3 in a row then check next
 00000E1B  80 3D 00000437 R		cmp		space7, "X"
	   58
 00000E22  75 3C			jne		oDiag1
 00000E24  80 3D 00000433 R		cmp		space5, "X"
	   58
 00000E2B  75 33			jne		oDiag1
 00000E2D  80 3D 0000042F R		cmp		space3, "X"
	   58
 00000E34  75 2A			jne		oDiag1
 00000E36  8B 5D 08			mov		ebx, [ebp+8] ; gameIsOver to ebx
 00000E39  B8 00000001			mov		eax, 1
 00000E3E  89 03			mov		[ebx], eax	 ; 1 to gameIsOver
 00000E40  E8 FFFFF420			call	displayBoard ; update board
 00000E45  8B 5D 10			mov		ebx, [ebp+16]; player1wins to ebx
 00000E48  B8 00000001			mov		eax, 1
 00000E4D  01 03			add		[ebx], eax	 ; increase player1wins by one
					displayString xWinMsg
 00000E4F  52		     1		push	edx
 00000E50  BA 00000233 R     1		mov		edx, OFFSET xWinMsg
 00000E55  E8 00000000 E     1		call	WriteString
 00000E5A  5A		     1		pop		edx
 00000E5B  E9 000000C7			jmp		gameEnd		 ; end procedure

 00000E60				oDiag1: ; check first diagonal O, if not 3 in a row then check next
 00000E60  80 3D 00000437 R		cmp		space7, "O"
	   4F
 00000E67  75 3C			jne		xDiag2
 00000E69  80 3D 00000433 R		cmp		space5, "O"
	   4F
 00000E70  75 33			jne		xDiag2
 00000E72  80 3D 0000042F R		cmp		space3, "O"
	   4F
 00000E79  75 2A			jne		xDiag2
 00000E7B  8B 5D 08			mov		ebx, [ebp+8] ; gameIsOver to ebx
 00000E7E  B8 00000001			mov		eax, 1
 00000E83  89 03			mov		[ebx], eax	 ; 1 to gameIsOver
 00000E85  E8 FFFFF3DB			call	displayBoard ; update board
 00000E8A  8B 5D 0C			mov		ebx, [ebp+12]; player2wins to ebx
 00000E8D  B8 00000001			mov		eax, 1
 00000E92  01 03			add		[ebx], eax	 ; increase player2wins by one
					displayString oWinMsg
 00000E94  52		     1		push	edx
 00000E95  BA 00000247 R     1		mov		edx, OFFSET oWinMsg
 00000E9A  E8 00000000 E     1		call	WriteString
 00000E9F  5A		     1		pop		edx
 00000EA0  E9 00000082			jmp		gameEnd		 ; end procedure

 00000EA5				xDiag2: ; check second diagonal X, if not 3 in a row then check next
 00000EA5  80 3D 0000042B R		cmp		space1, "X"
	   58
 00000EAC  75 39			jne		oDiag2
 00000EAE  80 3D 00000433 R		cmp		space5, "X"
	   58
 00000EB5  75 30			jne		oDiag2
 00000EB7  80 3D 0000043B R		cmp		space9, "X"
	   58
 00000EBE  75 27			jne		oDiag2
 00000EC0  8B 5D 08			mov		ebx, [ebp+8] ; gameIsOver to ebx
 00000EC3  B8 00000001			mov		eax, 1
 00000EC8  89 03			mov		[ebx], eax	 ; 1 to gameIsOver
 00000ECA  E8 FFFFF396			call	displayBoard ; update board
 00000ECF  8B 5D 10			mov		ebx, [ebp+16]; player1wins to ebx
 00000ED2  B8 00000001			mov		eax, 1
 00000ED7  01 03			add		[ebx], eax	 ; increase player1wins by one
					displayString xWinMsg
 00000ED9  52		     1		push	edx
 00000EDA  BA 00000233 R     1		mov		edx, OFFSET xWinMsg
 00000EDF  E8 00000000 E     1		call	WriteString
 00000EE4  5A		     1		pop		edx
 00000EE5  EB 40			jmp		gameEnd		 ; end procedure

 00000EE7				oDiag2: ; check second diagonal O, if not 3 in a row then check next
 00000EE7  80 3D 0000042B R		cmp		space1, "O"
	   4F
 00000EEE  75 37			jne		gameEnd
 00000EF0  80 3D 00000433 R		cmp		space5, "O"
	   4F
 00000EF7  75 2E			jne		gameEnd
 00000EF9  80 3D 0000043B R		cmp		space9, "O"
	   4F
 00000F00  75 25			jne		gameEnd
 00000F02  8B 5D 08			mov		ebx, [ebp+8] ; gameIsOver to ebx
 00000F05  B8 00000001			mov		eax, 1
 00000F0A  89 03			mov		[ebx], eax	 ; 1 to gameIsOver
 00000F0C  E8 FFFFF354			call	displayBoard ; update board
 00000F11  8B 5D 0C			mov		ebx, [ebp+12]; player2wins to ebx
 00000F14  B8 00000001			mov		eax, 1
 00000F19  01 03			add		[ebx], eax	 ; increase player2wins by one
					displayString oWinMsg
 00000F1B  52		     1		push	edx
 00000F1C  BA 00000247 R     1		mov		edx, OFFSET oWinMsg
 00000F21  E8 00000000 E     1		call	WriteString
 00000F26  5A		     1		pop		edx

 00000F27				gameEnd: ; end procedure
 00000F27  5D				pop		ebp
 00000F28  C2 000C			ret		12
 00000F2B			checkGameWin	ENDP

				;---------------------------------------------------
				; asks user if they want to play again
				;
				; registers used: edx, eax, ebx, esp, ebp
				; Receives: address of againBool
				; Returns: againBool
				;---------------------------------------------------
 00000F2B			playAgain		PROC
 00000F2B  55				push	ebp
 00000F2C  8B EC			mov		ebp, esp
					; ask if want to play again
					displayString againMsg	; prompt user
 00000F2E  52		     1		push	edx
 00000F2F  BA 0000010E R     1		mov		edx, OFFSET againMsg
 00000F34  E8 00000000 E     1		call	WriteString
 00000F39  5A		     1		pop		edx
 00000F3A  E8 00000000 E		call	ReadDec
 00000F3F  E8 00000000 E		call	Clrscr			; clear screen
 00000F44  83 F8 01			cmp		eax, 1			; enter 1 to play again
 00000F47  75 16			jne		endLabel3		; if user does not want to play again

					; want to play again, reset values
 00000F49  8B 5D 08			mov		ebx, [ebp+8]	  ; againBool to ebx
 00000F4C  B8 00000001			mov		eax, 1
 00000F51  89 03			mov		[ebx], eax		  ; 1 into againBool
 00000F53  68 0000041B R		push	OFFSET gameIsOver ; if game needs to restart
 00000F58  E8 00000010			call	resetGame		  ; reset board values
 00000F5D  EB 0A			jmp		endLabel4		  ; jump to end

 00000F5F				endLabel3:			 ; user does not want to play again
 00000F5F  8B 5D 08			mov		ebx, [ebp+8] ; againBool to ebx
 00000F62  B8 00000000			mov		eax, 0
 00000F67  89 03			mov		[ebx], eax	 ; 0 to againBool
 00000F69				endLabel4:			 ; exit label
 00000F69  5D				pop		ebp
 00000F6A  C2 0004			ret		4
 00000F6D			playAgain		ENDP

				;---------------------------------------------------
				; reset board state to play another game
				;
				; registers used: edx
				; Receives: address of gameIsOver
				; Returns: gameIsOver
				;---------------------------------------------------
 00000F6D			resetGame		PROC
 00000F6D  55				push	ebp
 00000F6E  8B EC			mov		ebp, esp
					; want to play again, reset values
					; clear spaces
 00000F70  C6 05 0000042B R		mov		space1, " "
	   20
 00000F77  C6 05 0000042D R		mov		space2, " "
	   20
 00000F7E  C6 05 0000042F R		mov		space3, " "
	   20
 00000F85  C6 05 00000431 R		mov		space4, " "
	   20
 00000F8C  C6 05 00000433 R		mov		space5, " "
	   20
 00000F93  C6 05 00000435 R		mov		space6, " "
	   20
 00000F9A  C6 05 00000437 R		mov		space7, " "
	   20
 00000FA1  C6 05 00000439 R		mov		space8, " "
	   20
 00000FA8  C6 05 0000043B R		mov		space9, " "
	   20
					; reset: spaces are not full
 00000FAF  C7 05 0000043D R		mov		space1Bool, 0
	   00000000
 00000FB9  C7 05 00000441 R		mov		space2Bool, 0
	   00000000
 00000FC3  C7 05 00000445 R		mov		space3Bool, 0
	   00000000
 00000FCD  C7 05 00000449 R		mov		space4Bool, 0
	   00000000
 00000FD7  C7 05 0000044D R		mov		space5Bool, 0
	   00000000
 00000FE1  C7 05 00000451 R		mov		space6Bool, 0
	   00000000
 00000FEB  C7 05 00000455 R		mov		space7Bool, 0
	   00000000
 00000FF5  C7 05 00000459 R		mov		space8Bool, 0
	   00000000
 00000FFF  C7 05 0000045D R		mov		space9Bool, 0
	   00000000

 00001009  8B 5D 08			mov		ebx, [ebp+8] ; gameIsOver to ebx
 0000100C  B8 00000000			mov		eax, 0
 00001011  89 03			mov		[ebx], eax	 ; 0 to gameIsOver

 00001013  5D				pop		ebp
 00001014  C2 0004			ret		4
 00001017			resetGame		ENDP

				;---------------------------------------------------
				; says goodbye to user
				;
				; registers used: edx
				; Receives: nothing
				; Returns: nothing
				;---------------------------------------------------
 00001017			goodbye			PROC
					; say goodbye
					displayString byeMsg
 00001017  52		     1		push	edx
 00001018  BA 00000153 R     1		mov		edx, OFFSET byeMsg
 0000101D  E8 00000000 E     1		call	WriteString
 00001022  5A		     1		pop		edx
					displayString userName
 00001023  52		     1		push	edx
 00001024  BA 000003AD R     1		mov		edx, OFFSET userName
 00001029  E8 00000000 E     1		call	WriteString
 0000102E  5A		     1		pop		edx
 0000102F  E8 00000000 E		call	CrLf
 00001034  C3				ret
 00001035			goodbye			ENDP

				;---------------------------------------------------
				; asks user if they want to play against a human or computer
				;
				; registers used: ebp, esp, edx, eax
				; Receives: address of gameModeType
				; Returns: gameModeType
				;---------------------------------------------------
 00001035			getGameMode		PROC
 00001035  55				push	ebp
 00001036  8B EC			mov		ebp, esp
					displayString gameModeMsg	; prompt
 00001038  52		     1		push	edx
 00001039  BA 0000017A R     1		mov		edx, OFFSET gameModeMsg
 0000103E  E8 00000000 E     1		call	WriteString
 00001043  5A		     1		pop		edx
 00001044  E8 00000000 E		call	ReadDec	
 00001049  8B 5D 08			mov		ebx, [ebp+8]		; address of gameModetype to ebx
 0000104C  89 03			mov		[ebx], eax			; move user input into gameModeType
 0000104E  E8 00000000 E		call	CrLf

 00001053  5D				pop		ebp
 00001054  C2 0004			ret		4
 00001057			getGameMode		ENDP

				END main
Microsoft (R) Macro Assembler Version 14.16.27026.1	    03/17/19 00:03:15
Tic Tac Toe     (TicTacToe.asm				     Symbols 2 - 1




Macros:

                N a m e                 Type

displayString  . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

CONSOLE_CURSOR_INFO  . . . . . .	 00000008
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  bVisible . . . . . . . . . . .	 00000004	 DWord
CONSOLE_SCREEN_BUFFER_INFO . . .	 00000016
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCursorPosition . . . . . . .	 00000004	 DWord
  wAttributes  . . . . . . . . .	 00000008	 Word
  srWindow . . . . . . . . . . .	 0000000A	 QWord
  dwMaximumWindowSize  . . . . .	 00000012	 DWord
COORD  . . . . . . . . . . . . .	 00000004
  X  . . . . . . . . . . . . . .	 00000000	 Word
  Y  . . . . . . . . . . . . . .	 00000002	 Word
FILETIME . . . . . . . . . . . .	 00000008
  loDateTime . . . . . . . . . .	 00000000	 DWord
  hiDateTime . . . . . . . . . .	 00000004	 DWord
FOCUS_EVENT_RECORD . . . . . . .	 00000004
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
FPU_ENVIRON  . . . . . . . . . .	 0000001C
  controlWord  . . . . . . . . .	 00000000	 Word
  statusWord . . . . . . . . . .	 00000004	 Word
  tagWord  . . . . . . . . . . .	 00000008	 Word
  instrPointerOffset . . . . . .	 0000000C	 DWord
  instrPointerSelector . . . . .	 00000010	 DWord
  operandPointerOffset . . . . .	 00000014	 DWord
  operandPointerSelector . . . .	 00000018	 Word
INPUT_RECORD . . . . . . . . . .	 00000014
  EventType  . . . . . . . . . .	 00000000	 Word
  Event  . . . . . . . . . . . .	 00000004	 XmmWord
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCommandId  . . . . . . . . .	 00000000	 DWord
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
KEY_EVENT_RECORD . . . . . . . .	 00000010
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
MENU_EVENT_RECORD  . . . . . . .	 00000004
  dwCommandId  . . . . . . . . .	 00000000	 DWord
MOUSE_EVENT_RECORD . . . . . . .	 00000010
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
SMALL_RECT . . . . . . . . . . .	 00000008
  Left . . . . . . . . . . . . .	 00000000	 Word
  Top  . . . . . . . . . . . . .	 00000002	 Word
  Right  . . . . . . . . . . . .	 00000004	 Word
  Bottom . . . . . . . . . . . .	 00000006	 Word
SYSTEMTIME . . . . . . . . . . .	 00000010
  wYear  . . . . . . . . . . . .	 00000000	 Word
  wMonth . . . . . . . . . . . .	 00000002	 Word
  wDayOfWeek . . . . . . . . . .	 00000004	 Word
  wDay . . . . . . . . . . . . .	 00000006	 Word
  wHour  . . . . . . . . . . . .	 00000008	 Word
  wMinute  . . . . . . . . . . .	 0000000A	 Word
  wSecond  . . . . . . . . . . .	 0000000C	 Word
  wMilliseconds  . . . . . . . .	 0000000E	 Word
WINDOW_BUFFER_SIZE_RECORD  . . .	 00000004
  dwSize . . . . . . . . . . . .	 00000000	 DWord


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 Para	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 00000461 Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00001057 Para	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

CloseFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CloseHandle  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Clrscr . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateFileA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateOutputFile . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Crlf . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Delay  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpMem  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpRegs . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToDosDateTime  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToSystemTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlushConsoleInputBuffer  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FormatMessageA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandLineA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandTail . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCP . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleScreenBufferInfo . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDateTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyState  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLastError . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMaxXY . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMseconds  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberOfConsoleInputEvents  .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessHeap . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStdHandle . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemTime  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTickCount . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Gotoxy . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapAlloc  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapCreate . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapDestroy  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapFree . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapSize . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
IsDigit  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalFree  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MessageBoxA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBoxAsk  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBox . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenInputFile  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseDecimal32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseInteger32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Random32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RandomRange  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Randomize  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadChar . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadDec  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFile . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFloat  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFromFile . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadHex  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadInt  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKeyFlush . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKey  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadString . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorPosition . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleScreenBufferSize . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTextAttribute  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTitleA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleWindowInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFilePointer . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ShowFPUStack . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Sleep  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StrLength  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_compare  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_copy . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_length . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_trim . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_ucase  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SystemTimeToFileTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WaitMsg  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBinB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBin . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteChar  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputAttribute  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputCharacterA . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteDec . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFloat . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHexB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHex . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteInt . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrameName  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrame  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteString  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteToFile  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteWindowsMsg  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
checkBoardFull . . . . . . . . .	P Near	 000008CF _TEXT	Length= 0000020D Public STDCALL
  space1Check  . . . . . . . . .	L Near	 000008D2 _TEXT	
  space2Check  . . . . . . . . .	L Near	 000008EC _TEXT	
  space3Check  . . . . . . . . .	L Near	 00000906 _TEXT	
  space4Check  . . . . . . . . .	L Near	 00000920 _TEXT	
  space5Check  . . . . . . . . .	L Near	 0000093A _TEXT	
  space6Check  . . . . . . . . .	L Near	 00000954 _TEXT	
  space7Check  . . . . . . . . .	L Near	 0000096E _TEXT	
  space8Check  . . . . . . . . .	L Near	 00000988 _TEXT	
  space9Check  . . . . . . . . .	L Near	 000009A2 _TEXT	
  space10Check . . . . . . . . .	L Near	 000009BC _TEXT	
  space1Full . . . . . . . . . .	L Near	 00000A51 _TEXT	
  space2Full . . . . . . . . . .	L Near	 00000A60 _TEXT	
  space3Full . . . . . . . . . .	L Near	 00000A6F _TEXT	
  space4Full . . . . . . . . . .	L Near	 00000A7E _TEXT	
  space5Full . . . . . . . . . .	L Near	 00000A8D _TEXT	
  space6Full . . . . . . . . . .	L Near	 00000A9C _TEXT	
  space7Full . . . . . . . . . .	L Near	 00000AAB _TEXT	
  space8Full . . . . . . . . . .	L Near	 00000ABA _TEXT	
  space9Full . . . . . . . . . .	L Near	 00000AC9 _TEXT	
  endLabel2  . . . . . . . . . .	L Near	 00000AD8 _TEXT	
checkGameWin . . . . . . . . . .	P Near	 00000ADC _TEXT	Length= 0000044F Public STDCALL
  oBottom  . . . . . . . . . . .	L Near	 00000B24 _TEXT	
  xMid . . . . . . . . . . . . .	L Near	 00000B69 _TEXT	
  oMid . . . . . . . . . . . . .	L Near	 00000BAE _TEXT	
  xTop . . . . . . . . . . . . .	L Near	 00000BF3 _TEXT	
  oTop . . . . . . . . . . . . .	L Near	 00000C38 _TEXT	
  xCol1  . . . . . . . . . . . .	L Near	 00000C7D _TEXT	
  oCol1  . . . . . . . . . . . .	L Near	 00000CC2 _TEXT	
  xCol2  . . . . . . . . . . . .	L Near	 00000D07 _TEXT	
  oCol2  . . . . . . . . . . . .	L Near	 00000D4C _TEXT	
  xCol3  . . . . . . . . . . . .	L Near	 00000D91 _TEXT	
  oCol3  . . . . . . . . . . . .	L Near	 00000DD6 _TEXT	
  xDiag1 . . . . . . . . . . . .	L Near	 00000E1B _TEXT	
  oDiag1 . . . . . . . . . . . .	L Near	 00000E60 _TEXT	
  xDiag2 . . . . . . . . . . . .	L Near	 00000EA5 _TEXT	
  oDiag2 . . . . . . . . . . . .	L Near	 00000EE7 _TEXT	
  gameEnd  . . . . . . . . . . .	L Near	 00000F27 _TEXT	
displayBoard . . . . . . . . . .	P Near	 00000265 _TEXT	Length= 0000017B Public STDCALL
getCpuMove . . . . . . . . . . .	P Near	 000007B4 _TEXT	Length= 0000011B Public STDCALL
  getRandomNum . . . . . . . . .	L Near	 000007B4 _TEXT	
  space1CPU  . . . . . . . . . .	L Near	 000007FC _TEXT	
  space2CPU  . . . . . . . . . .	L Near	 00000811 _TEXT	
  space3CPU  . . . . . . . . . .	L Near	 00000826 _TEXT	
  space4CPU  . . . . . . . . . .	L Near	 0000083B _TEXT	
  space5CPU  . . . . . . . . . .	L Near	 00000851 _TEXT	
  space6CPU  . . . . . . . . . .	L Near	 00000867 _TEXT	
  space7CPU  . . . . . . . . . .	L Near	 0000087D _TEXT	
  space8CPU  . . . . . . . . . .	L Near	 00000893 _TEXT	
  space9CPU  . . . . . . . . . .	L Near	 000008A9 _TEXT	
  cpuEnd . . . . . . . . . . . .	L Near	 000008BD _TEXT	
getGameMode  . . . . . . . . . .	P Near	 00001035 _TEXT	Length= 00000022 Public STDCALL
getMoveO . . . . . . . . . . . .	P Near	 000005CA _TEXT	Length= 000001EA Public STDCALL
  inputMove  . . . . . . . . . .	DWord	 bp - 00000004
  getMoveStartO  . . . . . . . .	L Near	 000005D0 _TEXT	
  oMove1 . . . . . . . . . . . .	L Near	 0000064F _TEXT	
  filledspace1o  . . . . . . . .	L Near	 00000664 _TEXT	
  oMove2 . . . . . . . . . . . .	L Near	 00000675 _TEXT	
  filledspace2o  . . . . . . . .	L Near	 0000068A _TEXT	
  oMove3 . . . . . . . . . . . .	L Near	 0000069B _TEXT	
  filledspace3o  . . . . . . . .	L Near	 000006B0 _TEXT	
  oMove4 . . . . . . . . . . . .	L Near	 000006C1 _TEXT	
  filledspace4o  . . . . . . . .	L Near	 000006D6 _TEXT	
  oMove5 . . . . . . . . . . . .	L Near	 000006E7 _TEXT	
  filledspace5o  . . . . . . . .	L Near	 000006FC _TEXT	
  oMove6 . . . . . . . . . . . .	L Near	 0000070D _TEXT	
  filledspace6o  . . . . . . . .	L Near	 00000722 _TEXT	
  oMove7 . . . . . . . . . . . .	L Near	 00000733 _TEXT	
  filledspace7o  . . . . . . . .	L Near	 00000745 _TEXT	
  oMove8 . . . . . . . . . . . .	L Near	 00000756 _TEXT	
  filledspace8o  . . . . . . . .	L Near	 00000768 _TEXT	
  oMove9 . . . . . . . . . . . .	L Near	 00000779 _TEXT	
  filledspace9o  . . . . . . . .	L Near	 0000078B _TEXT	
  invalidMoveO . . . . . . . . .	L Near	 0000079C _TEXT	
  endLabelO1 . . . . . . . . . .	L Near	 000007B2 _TEXT	
getMoveX . . . . . . . . . . . .	P Near	 000003E0 _TEXT	Length= 000001EA Public STDCALL
  inputMove  . . . . . . . . . .	DWord	 bp - 00000004
  getMoveStart . . . . . . . . .	L Near	 000003E6 _TEXT	
  xMove1 . . . . . . . . . . . .	L Near	 00000465 _TEXT	
  filledspace1x  . . . . . . . .	L Near	 0000047A _TEXT	
  xMove2 . . . . . . . . . . . .	L Near	 0000048B _TEXT	
  filledspace2x  . . . . . . . .	L Near	 000004A0 _TEXT	
  xMove3 . . . . . . . . . . . .	L Near	 000004B1 _TEXT	
  filledspace3x  . . . . . . . .	L Near	 000004C6 _TEXT	
  xMove4 . . . . . . . . . . . .	L Near	 000004D7 _TEXT	
  filledspace4x  . . . . . . . .	L Near	 000004EC _TEXT	
  xMove5 . . . . . . . . . . . .	L Near	 000004FD _TEXT	
  filledspace5x  . . . . . . . .	L Near	 00000512 _TEXT	
  xMove6 . . . . . . . . . . . .	L Near	 00000523 _TEXT	
  filledspace6x  . . . . . . . .	L Near	 00000538 _TEXT	
  xMove7 . . . . . . . . . . . .	L Near	 00000549 _TEXT	
  filledspace7x  . . . . . . . .	L Near	 0000055B _TEXT	
  xMove8 . . . . . . . . . . . .	L Near	 0000056C _TEXT	
  filledspace8x  . . . . . . . .	L Near	 0000057E _TEXT	
  xMove9 . . . . . . . . . . . .	L Near	 0000058F _TEXT	
  filledspace9x  . . . . . . . .	L Near	 000005A1 _TEXT	
  invalidMove  . . . . . . . . .	L Near	 000005B2 _TEXT	
  endLabel1  . . . . . . . . . .	L Near	 000005C8 _TEXT	
goodbye  . . . . . . . . . . . .	P Near	 00001017 _TEXT	Length= 0000001E Public STDCALL
introduction . . . . . . . . . .	P Near	 0000020B _TEXT	Length= 0000005A Public STDCALL
main . . . . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 0000020B Public STDCALL
  startAgain . . . . . . . . . .	L Near	 0000000A _TEXT	
  rematch  . . . . . . . . . . .	L Near	 00000034 _TEXT	
  humanLoop  . . . . . . . . . .	L Near	 00000041 _TEXT	
  player1Start . . . . . . . . .	L Near	 00000057 _TEXT	
  player2Start . . . . . . . . .	L Near	 000000A5 _TEXT	
  cpuStart . . . . . . . . . . .	L Near	 000000F8 _TEXT	
  cpuLoopStart . . . . . . . . .	L Near	 00000113 _TEXT	
  cpuMove  . . . . . . . . . . .	L Near	 0000014D _TEXT	
  endLoop  . . . . . . . . . . .	L Near	 00000187 _TEXT	
  player1Victory . . . . . . . .	L Near	 000001B9 _TEXT	
  player2Victory . . . . . . . .	L Near	 000001C7 _TEXT	
  askAgain . . . . . . . . . . .	L Near	 000001D3 _TEXT	
  goodbyeLabel . . . . . . . . .	L Near	 000001FF _TEXT	
playAgain  . . . . . . . . . . .	P Near	 00000F2B _TEXT	Length= 00000042 Public STDCALL
  endLabel3  . . . . . . . . . .	L Near	 00000F5F _TEXT	
  endLabel4  . . . . . . . . . .	L Near	 00000F69 _TEXT	
printf . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
resetGame  . . . . . . . . . . .	P Near	 00000F6D _TEXT	Length= 000000AA Public STDCALL
scanf  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
wsprintfA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000003h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
ALT_MASK . . . . . . . . . . . .	Number	 00000003h   
CAPSLOCK_ON  . . . . . . . . . .	Number	 00000080h   
CREATE_ALWAYS  . . . . . . . . .	Number	 00000002h   
CREATE_NEW . . . . . . . . . . .	Number	 00000001h   
CTRL_MASK  . . . . . . . . . . .	Number	 0000000Ch   
CreateFile . . . . . . . . . . .	Text   	 CreateFileA
DO_NOT_SHARE . . . . . . . . . .	Number	 00000000h   
ENABLE_ECHO_INPUT  . . . . . . .	Number	 00000004h   
ENABLE_LINE_INPUT  . . . . . . .	Number	 00000002h   
ENABLE_MOUSE_INPUT . . . . . . .	Number	 00000010h   
ENABLE_PROCESSED_INPUT . . . . .	Number	 00000001h   
ENABLE_PROCESSED_OUTPUT  . . . .	Number	 00000001h   
ENABLE_WINDOW_INPUT  . . . . . .	Number	 00000008h   
ENABLE_WRAP_AT_EOL_OUTPUT  . . .	Number	 00000002h   
ENHANCED_KEY . . . . . . . . . .	Number	 00000100h   
FALSE  . . . . . . . . . . . . .	Number	 00000000h   
FILE_APPEND_DATA . . . . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_ARCHIVE . . . . .	Number	 00000020h   
FILE_ATTRIBUTE_COMPRESSED  . . .	Number	 00000800h   
FILE_ATTRIBUTE_DEVICE  . . . . .	Number	 00000040h   
FILE_ATTRIBUTE_DIRECTORY . . . .	Number	 00000010h   
FILE_ATTRIBUTE_ENCRYPTED . . . .	Number	 00004000h   
FILE_ATTRIBUTE_HIDDEN  . . . . .	Number	 00000002h   
FILE_ATTRIBUTE_NORMAL  . . . . .	Number	 00000080h   
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED .	Number	 00002000h   
FILE_ATTRIBUTE_OFFLINE . . . . .	Number	 00001000h   
FILE_ATTRIBUTE_READONLY  . . . .	Number	 00000001h   
FILE_ATTRIBUTE_REPARSE_POINT . .	Number	 00000400h   
FILE_ATTRIBUTE_SPARSE_FILE . . .	Number	 00000200h   
FILE_ATTRIBUTE_SYSTEM  . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_TEMPORARY . . . .	Number	 00000100h   
FILE_BEGIN . . . . . . . . . . .	Number	 00000000h   
FILE_CURRENT . . . . . . . . . .	Number	 00000001h   
FILE_DELETE_CHILD  . . . . . . .	Number	 00000040h   
FILE_END . . . . . . . . . . . .	Number	 00000002h   
FILE_READ_DATA . . . . . . . . .	Number	 00000001h   
FILE_SHARE_DELETE  . . . . . . .	Number	 00000004h   
FILE_SHARE_READ  . . . . . . . .	Number	 00000001h   
FILE_SHARE_WRITE . . . . . . . .	Number	 00000002h   
FILE_WRITE_DATA  . . . . . . . .	Number	 00000002h   
FOCUS_EVENT  . . . . . . . . . .	Number	 00000010h   
FORMAT_MESSAGE_ALLOCATE_BUFFER .	Number	 00000100h   
FORMAT_MESSAGE_FROM_SYSTEM . . .	Number	 00001000h   
FormatMessage  . . . . . . . . .	Text   	 FormatMessageA
GENERIC_ALL  . . . . . . . . . .	Number	 10000000h   
GENERIC_EXECUTE  . . . . . . . .	Number	 20000000h   
GENERIC_READ . . . . . . . . . .	Number	 -80000000h   
GENERIC_WRITE  . . . . . . . . .	Number	 40000000h   
GetCommandLine . . . . . . . . .	Text   	 GetCommandLineA
HANDLE . . . . . . . . . . . . .	Text   	 DWORD
HEAP_GENERATE_EXCEPTIONS . . . .	Number	 00000004h   
HEAP_GROWABLE  . . . . . . . . .	Number	 00000002h   
HEAP_NO_SERIALIZE  . . . . . . .	Number	 00000001h   
HEAP_REALLOC_IN_PLACE_ONLY . . .	Number	 00000010h   
HEAP_ZERO_MEMORY . . . . . . . .	Number	 00000008h   
IDABORT  . . . . . . . . . . . .	Number	 00000003h   
IDCANCEL . . . . . . . . . . . .	Number	 00000002h   
IDCLOSE  . . . . . . . . . . . .	Number	 00000008h   
IDCONTINUE . . . . . . . . . . .	Number	 0000000Bh   
IDHELP . . . . . . . . . . . . .	Number	 00000009h   
IDIGNORE . . . . . . . . . . . .	Number	 00000005h   
IDNO . . . . . . . . . . . . . .	Number	 00000007h   
IDOK . . . . . . . . . . . . . .	Number	 00000001h   
IDRETRY  . . . . . . . . . . . .	Number	 00000004h   
IDTIMEOUT  . . . . . . . . . . .	Number	 00007D00h   
IDTRYAGAIN . . . . . . . . . . .	Number	 0000000Ah   
IDYES  . . . . . . . . . . . . .	Number	 00000006h   
INVALID_HANDLE_VALUE . . . . . .	Number	 -00000001h   
KBDOWN_FLAG  . . . . . . . . . .	Number	 00000001h   
KEY_EVENT  . . . . . . . . . . .	Number	 00000001h   
KEY_MASKS  . . . . . . . . . . .	Number	 0000001Fh   
LEFT_ALT_PRESSED . . . . . . . .	Number	 00000002h   
LEFT_CTRL_PRESSED  . . . . . . .	Number	 00000008h   
MAX_LENGTH_NAME  . . . . . . . .	Number	 00000065h   
MB_ABORTRETRYIGNORE  . . . . . .	Number	 00000002h   
MB_APPLMODAL . . . . . . . . . .	Number	 00000000h   
MB_CANCELTRYCONTINUE . . . . . .	Number	 00000006h   
MB_DEFBUTTON1  . . . . . . . . .	Number	 00000000h   
MB_DEFBUTTON2  . . . . . . . . .	Number	 00000100h   
MB_DEFBUTTON3  . . . . . . . . .	Number	 00000200h   
MB_DEFBUTTON4  . . . . . . . . .	Number	 00000300h   
MB_HELP  . . . . . . . . . . . .	Number	 00004000h   
MB_ICONASTERISK  . . . . . . . .	Number	 00000040h   
MB_ICONERROR . . . . . . . . . .	Number	 00000010h   
MB_ICONEXCLAMATION . . . . . . .	Number	 00000030h   
MB_ICONHAND  . . . . . . . . . .	Number	 00000010h   
MB_ICONINFORMATION . . . . . . .	Number	 00000040h   
MB_ICONQUESTION  . . . . . . . .	Number	 00000020h   
MB_ICONSTOP  . . . . . . . . . .	Number	 00000010h   
MB_ICONWARNING . . . . . . . . .	Number	 00000030h   
MB_OKCANCEL  . . . . . . . . . .	Number	 00000001h   
MB_OK  . . . . . . . . . . . . .	Number	 00000000h   
MB_RETRYCANCEL . . . . . . . . .	Number	 00000005h   
MB_SYSTEMMODAL . . . . . . . . .	Number	 00001000h   
MB_TASKMODAL . . . . . . . . . .	Number	 00002000h   
MB_USERICON  . . . . . . . . . .	Number	 00000080h   
MB_YESNOCANCEL . . . . . . . . .	Number	 00000003h   
MB_YESNO . . . . . . . . . . . .	Number	 00000004h   
MENU_EVENT . . . . . . . . . . .	Number	 00000008h   
MOUSE_EVENT  . . . . . . . . . .	Number	 00000002h   
MessageBox . . . . . . . . . . .	Text   	 MessageBoxA
NULL . . . . . . . . . . . . . .	Number	 00000000h   
NUMLOCK_ON . . . . . . . . . . .	Number	 00000020h   
OPEN_ALWAYS  . . . . . . . . . .	Number	 00000004h   
OPEN_EXISTING  . . . . . . . . .	Number	 00000003h   
PeekConsoleInput . . . . . . . .	Text   	 PeekConsoleInputA
RIGHT_ALT_PRESSED  . . . . . . .	Number	 00000001h   
RIGHT_CTRL_PRESSED . . . . . . .	Number	 00000004h   
ReadConsoleInput . . . . . . . .	Text   	 ReadConsoleInputA
ReadConsole  . . . . . . . . . .	Text   	 ReadConsoleA
SCROLLLOCK_ON  . . . . . . . . .	Number	 00000040h   
SHIFT_MASK . . . . . . . . . . .	Number	 00000010h   
SHIFT_PRESSED  . . . . . . . . .	Number	 00000010h   
STD_ERROR_HANDLE . . . . . . . .	Number	 -0000000Ch   
STD_INPUT_HANDLE . . . . . . . .	Number	 -0000000Ah   
STD_OUTPUT_HANDLE  . . . . . . .	Number	 -0000000Bh   
SetConsoleTitle  . . . . . . . .	Text   	 SetConsoleTitleA
TAB  . . . . . . . . . . . . . .	Number	 00000009h   
TRUE . . . . . . . . . . . . . .	Number	 00000001h   
TRUNCATE_EXISTING  . . . . . . .	Number	 00000005h   
VK_11  . . . . . . . . . . . . .	Number	 000000BDh   
VK_12  . . . . . . . . . . . . .	Number	 000000BBh   
VK_ADD . . . . . . . . . . . . .	Number	 0000006Bh   
VK_BACK  . . . . . . . . . . . .	Number	 00000008h   
VK_CANCEL  . . . . . . . . . . .	Number	 00000003h   
VK_CAPITAL . . . . . . . . . . .	Number	 00000014h   
VK_CLEAR . . . . . . . . . . . .	Number	 0000000Ch   
VK_CONTROL . . . . . . . . . . .	Number	 00000011h   
VK_DECIMAL . . . . . . . . . . .	Number	 0000006Eh   
VK_DELETE  . . . . . . . . . . .	Number	 0000002Eh   
VK_DIVIDE  . . . . . . . . . . .	Number	 0000006Fh   
VK_DOWN  . . . . . . . . . . . .	Number	 00000028h   
VK_END . . . . . . . . . . . . .	Number	 00000023h   
VK_ESCAPE  . . . . . . . . . . .	Number	 0000001Bh   
VK_EXECUTE . . . . . . . . . . .	Number	 0000002Bh   
VK_F10 . . . . . . . . . . . . .	Number	 00000079h   
VK_F11 . . . . . . . . . . . . .	Number	 0000007Ah   
VK_F12 . . . . . . . . . . . . .	Number	 0000007Bh   
VK_F13 . . . . . . . . . . . . .	Number	 0000007Ch   
VK_F14 . . . . . . . . . . . . .	Number	 0000007Dh   
VK_F15 . . . . . . . . . . . . .	Number	 0000007Eh   
VK_F16 . . . . . . . . . . . . .	Number	 0000007Fh   
VK_F17 . . . . . . . . . . . . .	Number	 00000080h   
VK_F18 . . . . . . . . . . . . .	Number	 00000081h   
VK_F19 . . . . . . . . . . . . .	Number	 00000082h   
VK_F1  . . . . . . . . . . . . .	Number	 00000070h   
VK_F20 . . . . . . . . . . . . .	Number	 00000083h   
VK_F21 . . . . . . . . . . . . .	Number	 00000084h   
VK_F22 . . . . . . . . . . . . .	Number	 00000085h   
VK_F23 . . . . . . . . . . . . .	Number	 00000086h   
VK_F24 . . . . . . . . . . . . .	Number	 00000087h   
VK_F2  . . . . . . . . . . . . .	Number	 00000071h   
VK_F3  . . . . . . . . . . . . .	Number	 00000072h   
VK_F4  . . . . . . . . . . . . .	Number	 00000073h   
VK_F5  . . . . . . . . . . . . .	Number	 00000074h   
VK_F6  . . . . . . . . . . . . .	Number	 00000075h   
VK_F7  . . . . . . . . . . . . .	Number	 00000076h   
VK_F8  . . . . . . . . . . . . .	Number	 00000077h   
VK_F9  . . . . . . . . . . . . .	Number	 00000078h   
VK_HELP  . . . . . . . . . . . .	Number	 0000002Fh   
VK_HOME  . . . . . . . . . . . .	Number	 00000024h   
VK_INSERT  . . . . . . . . . . .	Number	 0000002Dh   
VK_LBUTTON . . . . . . . . . . .	Number	 00000001h   
VK_LCONTROL  . . . . . . . . . .	Number	 000000A2h   
VK_LEFT  . . . . . . . . . . . .	Number	 00000025h   
VK_LMENU . . . . . . . . . . . .	Number	 000000A4h   
VK_LSHIFT  . . . . . . . . . . .	Number	 000000A0h   
VK_MENU  . . . . . . . . . . . .	Number	 00000012h   
VK_MULTIPLY  . . . . . . . . . .	Number	 0000006Ah   
VK_NEXT  . . . . . . . . . . . .	Number	 00000022h   
VK_NUMLOCK . . . . . . . . . . .	Number	 00000090h   
VK_NUMPAD0 . . . . . . . . . . .	Number	 00000060h   
VK_NUMPAD1 . . . . . . . . . . .	Number	 00000061h   
VK_NUMPAD2 . . . . . . . . . . .	Number	 00000062h   
VK_NUMPAD3 . . . . . . . . . . .	Number	 00000063h   
VK_NUMPAD4 . . . . . . . . . . .	Number	 00000064h   
VK_NUMPAD5 . . . . . . . . . . .	Number	 00000065h   
VK_NUMPAD6 . . . . . . . . . . .	Number	 00000066h   
VK_NUMPAD7 . . . . . . . . . . .	Number	 00000067h   
VK_NUMPAD8 . . . . . . . . . . .	Number	 00000068h   
VK_NUMPAD9 . . . . . . . . . . .	Number	 00000069h   
VK_PAUSE . . . . . . . . . . . .	Number	 00000013h   
VK_PRINT . . . . . . . . . . . .	Number	 0000002Ah   
VK_PRIOR . . . . . . . . . . . .	Number	 00000021h   
VK_RBUTTON . . . . . . . . . . .	Number	 00000002h   
VK_RCONTROL  . . . . . . . . . .	Number	 000000A3h   
VK_RETURN  . . . . . . . . . . .	Number	 0000000Dh   
VK_RIGHT . . . . . . . . . . . .	Number	 00000027h   
VK_RMENU . . . . . . . . . . . .	Number	 000000A5h   
VK_RSHIFT  . . . . . . . . . . .	Number	 000000A1h   
VK_SCROLL  . . . . . . . . . . .	Number	 00000091h   
VK_SEPARATER . . . . . . . . . .	Number	 0000006Ch   
VK_SHIFT . . . . . . . . . . . .	Number	 00000010h   
VK_SNAPSHOT  . . . . . . . . . .	Number	 0000002Ch   
VK_SPACE . . . . . . . . . . . .	Number	 00000020h   
VK_SUBTRACT  . . . . . . . . . .	Number	 0000006Dh   
VK_TAB . . . . . . . . . . . . .	Number	 00000009h   
VK_UP  . . . . . . . . . . . . .	Number	 00000026h   
WINDOW_BUFFER_SIZE_EVENT . . . .	Number	 00000004h   
WriteConsoleOutputCharacter  . .	Text   	 WriteConsoleOutputCharacterA
WriteConsole . . . . . . . . . .	Text   	 WriteConsoleA
againBool  . . . . . . . . . . .	DWord	 0000041F _DATA	
againMsg . . . . . . . . . . . .	Byte	 0000010E _DATA	
black  . . . . . . . . . . . . .	Number	 00000000h   
blue . . . . . . . . . . . . . .	Number	 00000001h   
boardLine1 . . . . . . . . . . .	Byte	 0000038B _DATA	
boardLine214 . . . . . . . . . .	Byte	 00000399 _DATA	
boardLine223 . . . . . . . . . .	Byte	 0000039B _DATA	
boardLine4 . . . . . . . . . . .	Byte	 0000039F _DATA	
brown  . . . . . . . . . . . . .	Number	 00000006h   
byeMsg . . . . . . . . . . . . .	Byte	 00000153 _DATA	
checkMsg . . . . . . . . . . . .	Byte	 000000E4 _DATA	
cpuMsg . . . . . . . . . . . . .	Byte	 00000268 _DATA	
currentChar  . . . . . . . . . .	Byte	 00000412 _DATA	
cyan . . . . . . . . . . . . . .	Number	 00000003h   
exit . . . . . . . . . . . . . .	Text   	 INVOKE ExitProcess,0
filledMsg  . . . . . . . . . . .	Byte	 00000214 _DATA	
gameIsOver . . . . . . . . . . .	DWord	 0000041B _DATA	
gameModeMsg  . . . . . . . . . .	Byte	 0000017A _DATA	
gameModeType . . . . . . . . . .	DWord	 00000423 _DATA	
getName  . . . . . . . . . . . .	Byte	 00000035 _DATA	
gray . . . . . . . . . . . . . .	Number	 00000008h   
green  . . . . . . . . . . . . .	Number	 00000002h   
greetMsg1  . . . . . . . . . . .	Byte	 0000004E _DATA	
greetMsg2  . . . . . . . . . . .	Byte	 00000056 _DATA	
instrcMsg2 . . . . . . . . . . .	Byte	 00000346 _DATA	
instrcMsg  . . . . . . . . . . .	Byte	 0000009A _DATA	
invalidMsg . . . . . . . . . . .	Byte	 000000F2 _DATA	
lightBlue  . . . . . . . . . . .	Number	 00000009h   
lightCyan  . . . . . . . . . . .	Number	 0000000Bh   
lightGray  . . . . . . . . . . .	Number	 00000007h   
lightGreen . . . . . . . . . . .	Number	 0000000Ah   
lightMagenta . . . . . . . . . .	Number	 0000000Dh   
lightRed . . . . . . . . . . . .	Number	 0000000Ch   
magenta  . . . . . . . . . . . .	Number	 00000005h   
oWinMsg  . . . . . . . . . . . .	Byte	 00000247 _DATA	
orderBool  . . . . . . . . . . .	DWord	 00000427 _DATA	
orderMsg . . . . . . . . . . . .	Byte	 0000028A _DATA	
player1Msg . . . . . . . . . . .	Byte	 000001E2 _DATA	
player1Wins  . . . . . . . . . .	DWord	 00000413 _DATA	
player1Won . . . . . . . . . . .	Byte	 000002EA _DATA	
player2Msg . . . . . . . . . . .	Byte	 000001FB _DATA	
player2Wins  . . . . . . . . . .	DWord	 00000417 _DATA	
player2Won . . . . . . . . . . .	Byte	 00000318 _DATA	
red  . . . . . . . . . . . . . .	Number	 00000004h   
rematchMsg . . . . . . . . . . .	Byte	 000002CD _DATA	
space1Bool . . . . . . . . . . .	DWord	 0000043D _DATA	
space1 . . . . . . . . . . . . .	Byte	 0000042B _DATA	
space2Bool . . . . . . . . . . .	DWord	 00000441 _DATA	
space2 . . . . . . . . . . . . .	Byte	 0000042D _DATA	
space3Bool . . . . . . . . . . .	DWord	 00000445 _DATA	
space3 . . . . . . . . . . . . .	Byte	 0000042F _DATA	
space4Bool . . . . . . . . . . .	DWord	 00000449 _DATA	
space4 . . . . . . . . . . . . .	Byte	 00000431 _DATA	
space5Bool . . . . . . . . . . .	DWord	 0000044D _DATA	
space5 . . . . . . . . . . . . .	Byte	 00000433 _DATA	
space6Bool . . . . . . . . . . .	DWord	 00000451 _DATA	
space6 . . . . . . . . . . . . .	Byte	 00000435 _DATA	
space7Bool . . . . . . . . . . .	DWord	 00000455 _DATA	
space7 . . . . . . . . . . . . .	Byte	 00000437 _DATA	
space8Bool . . . . . . . . . . .	DWord	 00000459 _DATA	
space8 . . . . . . . . . . . . .	Byte	 00000439 _DATA	
space9Bool . . . . . . . . . . .	DWord	 0000045D _DATA	
space9 . . . . . . . . . . . . .	Byte	 0000043B _DATA	
tieMsg . . . . . . . . . . . . .	Byte	 0000025B _DATA	
userName . . . . . . . . . . . .	Byte	 000003AD _DATA	
welcomeMsg . . . . . . . . . . .	Byte	 00000000 _DATA	
white  . . . . . . . . . . . . .	Number	 0000000Fh   
wsprintf . . . . . . . . . . . .	Text   	 wsprintfA
xWinMsg  . . . . . . . . . . . .	Byte	 00000233 _DATA	
yellow . . . . . . . . . . . . .	Number	 0000000Eh   

	   0 Warnings
	   0 Errors
